---
title: "Ingresos medios de los hogares por regiones NUTS 2"
author: "Aythami Lorenzo Padilla"
date: "`r Sys.Date()`"
output:
  html_document:
  pdf_document: default
---

<!--
# TRUCOS ÚTILES AL EDITAR UN FICHERO Rmarkdown: 
(1) TECLAS: CTRL-MAY-1 : EDICIÓN DE CÓDIGO OCUPA/NO OCUPA TODA LA VENTANA
(2) TECLAS: CTRL-ALT-C : EJECUTA UN CHUNK CUANDO EL CURSOR DEL RATÓN ESTA DENTRO DEL CHUNK (OTRA FORMA ES HACER CLICK EN EL BOTÓN TRIANGULAR VERDE EN LA ESQUINA SUPERIOR DERECHA DEL CHUNK)
(3) ACTIVAR "knit on Save" PARA COMPILAR AUTOMÁTICAMENTE AL GUARDAR EL ARCHIVO (CTRL-S)
PARA CREAR UN CHUNK NUEVO USAR BOTÓN VERDE CON UNA "C" EN LA PARTE SUPERIOR DERECHA DE LA VENTANA
(4) PARA EJECUTAR UNA PORCIÓN DE CÓDIGO O VISUALIZAR EL VALOR DE UNA TABLA/VARIABLE SELECCIONAR EL CÓDIGO CON EL RATÓN Y HACER CTRL-ENTER -->

<!-- Opcionalmente, el formateo de este documento en HTML se puede mejorar usando CSS -->

```{r message=FALSE, warning=FALSE, include=FALSE}
Sys.setlocale("LC_ALL", "es_ES.UTF-8")

```

```{r librerias, include=FALSE}
# carga de librerías
library(DT)
library(googlesheets4)
library(kableExtra)
library(flexdashboard)
library(highcharter) 
library(fpp3)
library(openxlsx)  
library(leaflet)  
library(geojsonio)
library(plotly)
library(ggplot2)
library(gganimate)
library(tidyverse)
library(eurostat)
library(knitr)
source("utilidades.R")



# asociamos funciones a determinadas librerías para evitar posibles errores 
filter <- dplyr::filter # Filtra filas según condiciones
select <- dplyr::select # Selecciona columnas
mutate <- dplyr::mutate # Crea o modifica columnas
arrange <- dplyr::arrange # Ordena filas
group_by <- dplyr::group_by # Agrupa datos
summarise <- dplyr::summarise # Resume variables (por ejemplo, con medias, conteos)
summarize <- dplyr::summarize # Lo mismo que summarise
rename <- dplyr::rename # Cambia nombres de columnas
distinct <- dplyr::distinct # Elimina filas duplicadas
slice<- dplyr::slice # Selecciona filas por posición
relocate<- dplyr::relocate # Reordena columnas

selectInput <- shiny::selectInput



```

```{css estilo_memoria, echo = FALSE}
<style>
/* Fuente principal: Times New Roman para todo el documento */
body {
  font-family: "Times New Roman", Times, serif;
  font-size: 16px;
  line-height: 1.7;
  color: #2d3748;
  background-color: #ffffff;
  max-width: 960px;
  margin: 0 auto;
  padding: 30px;
}

/* Estilo para todos los encabezados */
h1, h2, h3, h4 {
  font-family: "Times New Roman", Times, serif;
  font-weight: bold;
  color: #1a202c;
  margin-top: 2em;
  margin-bottom: 0.8em;
  position: relative;
}

p {
font-family: "Times New Roman"
}

/* Forzar fuente en listas desordenadas y ordenadas */
ul, ol, li {
  font-family: "Times New Roman", Times, serif;
}

/* Subrayado bajo todos los títulos */
h1:after,
h2:after,
h3:after,
h4:after {
  content: "";
  position: absolute;
  bottom: -8px;
  left: 0;
  height: 2px;
  background-color: #cbd5e0;
  width: 100%;
}

/* Línea vertical lateral izquierda en h2, h3, h4 */
h2:before,
h3:before,
h4:before {
  content: "";
  position: absolute;
  top: 0;
  left: -18px;
  width: 4px;
  height: 100%;
  background-color: #4299e1;
  border-radius: 2px;
}

/* Asegurar que SOLO los números de sección generados por R Markdown se vean en cursiva */
h2 .header-section-number,
h3 .header-section-number,
h4 .header-section-number {
  font-style: italic;
}

/* Código y bloques técnicos */
pre, code {
  font-family: 'Fira Code', 'Consolas', monospace;
  background-color: #f8fafc;
  border-radius: 6px;
  font-size: 0.95em;
}

pre {
  padding: 16px;
  border-left: 4px solid #cbd5e0;
  overflow-x: auto;
  margin: 1.2em 0;
}

/* Tablas limpias y centradas */
table {
  width: auto;
  max-width: 100%;
  margin: 1.5em auto;
  border-collapse: collapse;
  font-size: 0.95em;
}

th {
  background-color: #edf2f7;
  color: #2d3748;
  font-weight: bold;
  padding: 10px 14px;
  text-align: left;
}

td {
  padding: 9px 14px;
  border-bottom: 1px solid #e2e8f0;
}

tr:nth-child(even) {
  background-color: #f8fafc;
}

/* Imágenes centradas y con márgenes adecuados */
img {
  display: block;
  margin: 1.8em auto;
  max-width: 100%;
  height: auto;
  border-radius: 4px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.05);
}

/* Citas o bloques destacados */
blockquote {
  margin: 1.8em 0;
  padding: 1em 1.4em;
  border-left: 4px solid #a0aec0;
  background-color: #f8fafc;
  color: #4a5568;
  font-style: "Times New Roman";
  border-radius: 0 4px 4px 0;
}

/* Enlaces con estilo sutil */
a {
  color: #3182ce;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
  color: #2b6cb0;
}

/* Pie de página discreto */
footer {
  margin-top: 4em;
  padding-top: 1.5em;
  border-top: 1px solid #e2e8f0;
  color: #718096;
  font-size: 0.9em;
  text-align: center;
}

/* Ajuste fino para dispositivos móviles */
@media (max-width: 768px) {
  body {
    padding: 18px;
    font-size: 15px;
  }
  h1 { font-size: 1.9em; }
  h2 { font-size: 1.4em; }
}

/* leaflet general */
.leaflet-container {
    background-color: #ffffff !important;
    font-family: serif !important;
}

/* Leyenda de los leaflet */
.info.legend.leaflet-control {
    font-family: serif !important;
    color: black !important;
    box-shadow: none !important;
}

/* Botones zoom */

.leaflet-control-zoom a {

    border: 0px !important;

    color: #aaaaaa !important;

    box-shadow: none !important;

}



/* Botones zoom */

.leaflet-control-zoom {

    border-radius: 0px !important;

}


</style>

```

```{r estilo_graficas, results='hide', include=FALSE}
theme_set(
  theme(
    text = element_text(family = "serif", color = "#222222"),
    plot.title = element_text(family = "serif", face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(family = "serif", face = "italic", size = 15, hjust = 0.5),
    axis.title = element_text(family = "serif", face = "bold", size = 13),
    axis.text = element_text(family = "serif", size = 10),
    legend.title = element_text(family = "serif", face = "bold", size = 14),
    legend.text = element_text(family = "serif", size = 12),
    plot.margin = margin(15, 15, 15, 15),
  )
)

# Fuente serif también para textos dentro de los gráficos (geom_text y geom_label)
update_geom_defaults("text", list(family = "serif"))
update_geom_defaults("label", list(family = "serif"))


```


```{r,echo=FALSE}
# OPCIONES POR DEFECTO AL COMPILAR LOS CHUNKS 
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  cache=FALSE, # ponerlo a TRUE acelera la compilación pues solo recompila los chunks modificados. Es útil al escribir texto con mucho código que tarda tiempo en compilar. Puede fallar cuando unos chunks dependen de otros. En ese caso, o cuando hay errores que no entiendes, borra la carpeta auxiliar que se genera con la extensión "_cache" para obligar a recompilar todo. 
  echo=FALSE
)
```



<!-- Todos los proyectos personales tienen que tener un cuadro de mandos (Tema 7 de la asignatura) cuya dirección es similar a la que sigue poniendo tu nº de usuario (en lugar de a2405) y el nombre del Rmd asociado. Los cuadros de mando se alojan en un servidor del DIS y solo se puede acceder a ellos a través de la red de la ULPGC o usando VPN -->

[Cuadro de mandos](http://10.22.143.222:3838/sample-apps/a2629/DashboardProyectoPersonal.Rmd)


<!-- Añadir imagen ilustrativa del tema de mi proyecto --> 
<center>
<img src= "portada.jpg" width="80%" />
</center>

# Introducción


En el marco socioeconómico de la Unión Europea, la cohesión territorial y la reducción de las desigualdades siguen siendo desafíos primordiales. Si bien los indicadores macroeconómicos nacionales suelen acaparar la atención mediática, la renta disponible de los hogares se erige como el indicador más fiel para medir el bienestar real de la ciudadanía, su capacidad de consumo y su nivel de ahorro. En la coyuntura actual, marcada por la recuperación post-pandemia y las tensiones inflacionarias, analizar la evolución de la riqueza familiar no es solo un ejercicio estadístico, sino una herramienta fundamental para evaluar la salud económica real de las familias y la efectividad de las políticas de convergencia europeas.

El problema central que aborda este proyecto radica en que los promedios nacionales a menudo enmascaran profundas disparidades internas. Un análisis limitado al nivel de país (NUTS 0) es insuficiente para comprender la realidad de territorios con dinámicas propias. Por tanto, este estudio desciende al nivel NUTS 2 para visibilizar estas brechas, delimitando el análisis a la evolución comparada de las regiones europeas durante las últimas dos décadas (2000-2022). Específicamente, se pone el foco en la posición relativa de las Comunidades Autónomas españolas, y de manera singular en Canarias como región ultraperiférica, para determinar si existe una convergencia real en términos de renta neta y poder adquisitivo (PPS) frente a los estándares europeos o si, por el contrario, la brecha regional tiende a perpetuarse.


##  Estado actual

<br>

En el contexto de la economía regional europea, el análisis de la convergencia y la cohesión territorial ha estado tradicionalmente dominado por indicadores agregados a nivel nacional, como el Producto Interior Bruto (PIB). Sin embargo, existe un consenso creciente en la literatura económica y en instituciones como Eurostat sobre las limitaciones de estas métricas para reflejar el bienestar efectivo de la ciudadanía. El "estado del arte" actual se desplaza hacia el estudio de la **Renta Disponible de los Hogares** ajustada por el poder adquisitivo (PPS) y desagregada a niveles territoriales más finos, como el nivel **NUTS 2**, que es la unidad base para la aplicación de las políticas de desarrollo regional de la UE.

### Justificación y Relevancia del Estudio

La realización de este estudio se justifica por la necesidad de superar la "ceguera de los promedios nacionales". Estudios precedentes han demostrado que, si bien puede existir convergencia entre países, las **disparidades intrarregionales** a menudo se mantienen o incluso se amplían, especialmente tras choques asimétricos como la crisis financiera de 2008 o la pandemia de COVID-19.

En el caso específico de **España**, la literatura identifica una persistente dualidad norte-sur y una brecha significativa entre las regiones capitalinas/industriales y las periféricas. Este proyecto cobra especial relevancia y oportunidad al centrar el foco en:

* **La realidad granular:** Analizar la evolución de regiones específicas como **Canarias** (Región Ultraperiférica) permite evaluar si los mecanismos de compensación europeos están logrando una convergencia real en el nivel de vida o si existe un desacople estructural respecto al núcleo de la UE.

* **Más allá del PIB:** Al integrar variables como el **Ahorro Neto**, la **Presión Fiscal** y la **Inversión**, este estudio ofrece una visión multidimensional del bienestar que va más allá de la mera producción económica.

* **Contexto temporal crítico:** El periodo de estudio (2000-2022) es idóneo para analizar la resiliencia regional a largo plazo, abarcando ciclos completos de expansión y recesión, lo que permite modelar tendencias futuras con mayor robustez.

## Motivación

Una de las principales motivaciones que me ha llevado a elegir un dataset de este tema es una aspiración que tengo de vivir o estudiar fuera de España, sobretodo por temas laborales entre otros y por calidad de vida. Yo considero que los aspectos económicos son un factor muy importante a tener en cuenta para esto, el poder comparar a España con otros países o incluso poder comparar España internamente para ver como es económicamente en distintos factores es algo que me ha impulsado a elegir este tema de trabajo. Además, las cuestiones económicas siempre me han llamado más la atención que cualquier otra.

## Objetivos

<!-- Expresa de forma amplia y global el propósito principal del trabajo. Cuales son sus metas principales -->

# Aportaciones del trabajo

<!-- estas sección se suele escribir al final del trabajo --> 

## Principales aportaciones

<!-- Análisis del significado e implicaciones de los resultados en el contexto del área de estudio. Nuevas perspectivas o enfoques. Actualización del conocimiento existente. Debe estar alineado con los objetivos. Comentar cuadro de mandos como aportación  -->


## Alineamiento con los objetivos de desarrollo sostenible

<!-- Hay que rellenar el fichero "ODS.xlsx" con nuestros datos. Si en ChatGPT hacemos la consulta "Relacionar "mi tema de proyecto" con ODS" nos saldrá un borrador de relaciones que podremos usar como base y  perfeccionar. --> 

```{r}
tb <- read.xlsx("ODS.xlsx") %>%
  as_tibble()
tb[is.na(tb)] <- ""

colnames(tb) <- c("ODS","No procede", "Bajo", "Medio","Alto")
tabla <- kbl(tb,
    caption = "Grado de relación del proyecto con los ODS",
    booktabs = TRUE,
    linesep = ""
  ) 
  
if (knitr::is_latex_output()) {
  tabla <- tabla %>%
    kable_styling(
      latex_options = c("hold_position", "scale_down"),
      font_size = 8,
      position = "center"
    ) %>%
    column_spec(1, width = "4cm") %>%
    column_spec(2:5, width = "2cm", latex_valign = "m")
} else {
  tabla <- tabla %>%
    kable_styling(
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(2:5, extra_css = "text-align: center;")
}

tabla
```


# Desarrollo


## Herramientas empleadas

<br>

El desarrollo de este proyecto se ha sustentado en un ecosistema de herramientas de código abierto, seleccionadas por su robustez en el análisis estadístico, su capacidad de visualización y su flexibilidad para el desarrollo de aplicaciones web interactivas.

### R y RStudio: El Núcleo del Análisis

<br>

Como lenguaje de programación principal se ha utilizado **R**, debido a su posición dominante en el ámbito de la estadística y la ciencia de datos. Su capacidad nativa para manejar grandes volúmenes de datos estructurados y su inmensa colección de paquetes especializados lo convierten en la elección óptima frente a otras alternativas.

El entorno de desarrollo integrado (IDE) elegido ha sido **RStudio**. Su interfaz facilita la gestión simultánea de scripts, consolas, visualización de gráficos y control de entornos, lo cual ha sido crucial para iterar rápidamente en el análisis exploratorio y la depuración del código.

### Librerías Principales

<br>

El proyecto se apoya en un conjunto de librerías clave que han permitido transformar los datos brutos en conocimiento visualizable:

* `tidyverse` **(dplyr, tidyr, ggplot2):** La columna vertebral del proyecto. Se ha empleado para la manipulación, limpieza y transformación de los datos (data wrangling), así como para la generación de gráficos estáticos de alta calidad mediante la gramática de gráficos.

* `eurostat`: Fundamental para la ingesta automatizada y normalizada de los datos de población directamente desde la base de datos oficial de la Comisión Europea, garantizando la reproducibilidad del análisis.

* `plotly` y `highcharter`: Utilizadas para dotar de interactividad avanzada a las visualizaciones, permitiendo al usuario final explorar los datos (tooltips, zoom, filtrado) de manera dinámica dentro del cuadro de mandos.

* `gganimate`: Esta librería ha sido clave para incorporar la dimensión temporal de forma dinámica, permitiendo la creación de gráficos animados que ilustran la evolución del ranking de renta por países año a año, facilitando la comprensión de las tendencias de convergencia.

* `leaflet` y `geojsonio`: Esenciales para el componente geoespacial. Han permitido la lectura de archivos GeoJSON y el renderizado de mapas coropléticos interactivos, integrando las geometrías NUTS con los indicadores económicos.

* `fpp3` **(fable, tsibble):** Empleada para el análisis avanzado de series temporales. Ha facilitado la conversión de datos a estructuras temporales (`tsibble`), el tratamiento de huecos (`fill_gaps`) y la generación de modelos predictivos **ARIMA.**

* `DT` y `kableExtra`: Utilizadas para la presentación tabular de los datos. `DT` ha permitido crear tablas interactivas con paginación y búsqueda en el cuadro de mandos, mientras que `kableExtra` se ha usado para el formateo estático de tablas en la memoria.

* `openxlsx` y `googlesheets4`: Empleadas para la interoperabilidad con fuentes de datos externas. openxlsx ha permitido la ingesta de metadatos locales (relación con los ODS), mientras que googlesheets4 ha posibilitado la conexión en tiempo real con la hoja de cálculo de seguimiento del proyecto alojada en la nube.

* `flexdashboard` y `shiny`: Estas librerías han sido la base para la construcción del producto final. `flexdashboard` ha permitido estructurar el análisis en un layout de cuadro de mandos (dashboard) responsivo, mientras que `shiny` ha inyectado la lógica reactiva necesaria (inputs dinámicos, renderizado condicional) para que los filtros y selectores controlen los gráficos en tiempo real.

### Servidor Shiny del DIS

<br>

Para la difusión y acceso público del cuadro de mandos, se ha optado por el despliegue en el servidor **Shiny del Departamento de Informática y Sistemas (DIS).** Esta infraestructura permite alojar la aplicación de manera estable, asegurando que el procesamiento reactivo de los datos (como los modelos ARIMA o los filtros dinámicos de regiones) se ejecute en el servidor y se sirva al usuario final a través de cualquier navegador web. 

## Metodología


Utilizaremos la metodología de desarrollo CRISP-DM (Cross Industry Standard Process for Data Mining) que es un marco ampliamente utilizado para proyectos de Ciencias de Datos. En la siguiente figura se presenta un diagrama con las diferentes fases de esta metodología que a continuación describimos con más detalle: 

<center>
<img src="https://ctim.es/AEDV/1200px-CRISP-DM_Process_Diagram1.5x.png" width="40%" />
<p style="font-size: 14px; color: gray;"><em>Diagrama metodología de desarrollo CRISP-DM</em></p>
</center>



* **Comprensión del negocio**. Se plantean los objetivos del proyecto y la búsqueda de información y datos. 

<!-- Una parte de esta fase incluye la descripción del objeto del proyecto y sus objetivos, como eso ya se ha presentado anteriormente en la memoria no se repite aquí. Otra parte que si se incluye es describir lo que se ha hecho para  la búsqueda de datos, las fuentes consultadas, entrevistas, lecturas bibliográficas, etc.. señalando las incidencias/dificultades encontradas, así como el análisis de la fiabilidad de la información obtenida. En esta fase no se realiza una descripción detallada de los datos ni pondremos gráficas.  -->

* **Comprensión de los datos**. Se analiza la  estructura y organización de los datos obtenidos. Se identifican posible problemas como datos faltantes, outliers o inconsistencias. 

<!-- Identificar y describir con claridad el significado de las variables categóricas existentes (y todos los valores que pueden tomar) y las observaciones (habitualmente valores numéricos). Identificar si los datos están organizados de forma ordenada (tidy), es decir una sola observación por cada fila de la tabla acompañada de variables categóricas o de forma no ordenada, es decir, varias observaciones por cada fila. En este caso,  habitualmente, los valores posibles de una variable categórica se distribuyen como títulos de columnas de la tabla y cada celda de esas columnas incluye una observación. Estudiar la frecuencia (Nº de observaciones) asociadas a las variables categóricas, el tamaño e intervalo temporal de las series temporales (si procede), la distribución del nº de observaciones por regiones, o por otro tipo de desglose de la información (si procede), análisis de los atributos combinados existentes, dados por las combinaciones de variables categóricas que aparecen en el dataset. Analizar en más detalle (si hubiera lugar) como son los datos en la regiones que más me interesan. Identificación de errores, valores ausentes, outliers o cualquier otra incosistencia encontrada. 

En esta fase no se realiza procesado de datos salvo el mínimo para obtener la información que se requiere. Tampoco se entra a valorar la calidad de los datos o como habría que procesarlos. En términos médicos, esta sería la fase del diagnóstico donde todavía no se comenta nada del pronóstico del paciente o del tratamiento. Por tanto no se expresan opiniones sobre los datos, solo se exponen tal cual son. 

En esta fase, en general, no pondremos gráficos, salvo cosas muy sencillas relativas a las frecuencias de los datos y cosas de ese tipo, pues los gráficos requieren, en general, selección y procesamiento de datos previo. 

El análisis de lo datos realizado para la validación del tema del proyecto personal va en este apartado. 

--> 

<!-- En esta fase, a partir de los resultados de la fase anterior, estudiamos la relevancia y calidad de la información obtenida en la fase anterior de acuerdo con los objetivos del proyecto, si procede seleccionamos/eliminamos variables categóricas o algunas de sus opciones, exponiendo con claridad y justificadamente los atributos combinados (formados por combinaciones de variables categóricas) que vamos a usar en el estudio. Decidimos el intervalo temporal que vamos a usar para  nuestro estudio. Realizamos la limpieza, transformación,  creación de nuevas variables, combinación de tablas,etc... En esta fase pondremos las gráficas que ilustran los datos una vez procesados y seleccionados pero sin usar los modelos que se formulan en la siguiente fase.  --> 

* **Modelado**. Selección y aplicación de los modelos adecuados para analizar los datos 

<!-- Se aplican a los datos los modelos utilizados, como por ejemplo, regresión lineal, modelos ARIMA, matriz de correlación, PCA, etc.. En esta fase se pondrán gráficas sobre el uso de de estos modelos.  --> 

* **Evaluación**. Evaluar si el modelo responde a las preguntas de investigación, comparación con otros métodos 

<!-- Se discuten de forma crítica los resultados obtenidos incluyendo pruebas de evaluación / validación realizadas (si procede) --> 

* **Despliegue**. Comunicación del trabajo en una memoria y diseño y elaboración de un cuadro de mandos para presentar los resultados de forma eficaz y atractiva. 

<!-- El despliegue de este proyecto se realizará a través de la confección de esta memoria y de un cuadro de mandos. --> 

 
 <!-- De acuerdo con esta metodología, los resultados se van presentando, discutiendo y validando a lo largo de las fases de **Modelado**, **Evaluación** y **Despliegue** y, por tanto, para mantener una estructura coherente de la memoria, de acuerdo con la aplicación de la  metodología CRISP-DM, no existe en la memoria una sección separada de presentación de resultados.  --> 
 
 
 Es importante observar que esta metodología es iterativa, es decir que los resultados obtenidos en algunas de las fases puede afectar al desarrollo de fases anteriores. 
 
 A continuación se describirá en detalle como se han abordado cada una de las fases del desarrollo del proyecto siguiendo esta metodología.

* **Preparación de los datos**. Se realiza limpieza, transformación, combinación y selección/creación de variables relevantes para el análisis.

## Comprensión del negocio

Para la búsqueda de datos, lo que se ha hecho es buscar directamente en la lista de datasets de Eurostat, en primer lugar había encontrado un dataset interesante pero este prácticamente hacía imposible la combinación de atributos además de tener inexistentes o pocos datos para España y Canarias, finalmente encontré el dataset con el que he trabajado y en este caso apenas he tenido incidencias o dificultades.

Para la búsqueda del segundo dataset han existido mas problemas ya que principalmente teníamos un dataset de población y sumábamos por grupos para concentrar a la poblacion entre 15 y 65 años y de esta manera normalizar los valores de los atributos, sin embargo, este dataset tenía problemas ya que los valores eran observaciones tomadas el 1 de enero de cada año, esto hacía que los resultados fueran valores lejanos de la realidad. El problema es que normalmente para calcular datos económicos per cápita no se suele separar por grupos y lo que se hace es tomar datos de poblaciones que representen la media de la población en un año, dicho esto, tuve que buscar otro dataset que contaba con estas característica y que proporcionaba valores mucho más exactos.

## Comprensión de los datos

```{r desc_variables, echo = FALSE, message = FALSE, warning = FALSE, results = 'hide'}
dataset.name <- "nama_10r_2hhinc"
# data <- get_eurostat(dataset.name, time_format = "date") %>%
  # as_tibble() %>%
  # arrange(TIME_PERIOD, geo)

data <- read.csv("nama_10r_2hhinc.csv") %>% 
  as_tibble() %>% 
  mutate(TIME_PERIOD = as.Date(TIME_PERIOD)) %>% 
  arrange(TIME_PERIOD, geo) 
```

### Descripción de variables categóricas y observaciones


El conjunto de datos contiene información anual sobre diversas partidas de ingreso de los hogares, desglosada por regiones NUTS. Las variables categóricas (dimensiones) que estructuran el dataset se describen a continuación:


**Frecuencia de las observaciones** (`freq`) -> Define la periodicidad con la que se registran las observaciones.

  * **A (Anual):** La información es recolectada y reportada con una periodicidad de un año.

<br>

**Unidad de Medida** (`unit`) -> Especifica la unidad utilizada para expresar el valor numérico (`values`) de la observación. Es crucial para garantizar la comparabilidad de los datos.

  * **EUR\_HAB** -> **Euros por habitante.** Muestra la cifra de ingresos dividida por el número de personas en la región. Se utiliza para medir la **renta promedio individual** en euros. *No está ajustada por lo que valen las cosas en esa región.*

  * **MIO\_EUR** -> **Millones de Euros.** Es el valor total de los ingresos de la región. Se utiliza para medir el **tamaño o volumen total** de la economía regional en la moneda común.

  * **MIO\_NAC** -> **Millones de Moneda Nacional.** Es el valor total en la moneda del país **antes** de que adoptara el Euro (por ejemplo, en pesetas o francos). Solo es útil para analizar datos de **años anteriores** a la zona Euro.

  * **MIO\_PPS\_EU27\_2020** -> **Millones de Estándares de Poder Adquisitivo (PPS).** El PPS es una "moneda de     comparación" que **elimina el efecto de los precios**. Si una región es muy cara, el PPS ajusta el ingreso a la baja; si es barata, lo ajusta al alza. Se usa para comparar el **volumen económico real** entre regiones.

  * **PPS\_EU27\_2020\_HAB** -> **PPS por habitante.** Es la métrica más valiosa para las comparaciones. Muestra el ingreso promedio por persona, pero **ajustado por el costo de vida**. Esta unidad refleja de forma más precisa el **nivel de vida real** y la capacidad de compra de los habitantes en distintas regiones.


<br>


**Dirección de Flujo** (`direct`) -> Indica la naturaleza de la transacción económica, especificando si es un saldo o una operación de pago/recepción.

  * **BAL (Balance):** Representa un **saldo neto** (la diferencia entre ingresos y gastos o entre activos y pasivos). Es el resultado final de una cuenta económica.
  
  * **PAID (Pagado):** Hace referencia al valor de las **transferencias o pagos** realizados por el sector de los hogares.
  
  * **RECV (Recibido):** Hace referencia al valor de los **ingresos o transferencias** recibidas por el sector de los hogares.

<br>

**Indicador de Cuentas Nacionales** (`na_item`) -> Esta es la dimensión clave que define la variable económica exacta que se está midiendo, siguiendo la nomenclatura del Sistema Europeo de Cuentas (SEC 2010).

  * **B5N** ->  **Ingreso Primario Neto:** El saldo de las rentas que reciben los hogares por su participación directa en la producción y la propiedad (salarios, rentas de la propiedad e ingresos de autoempleo), antes de transferencias e impuestos.

  * **B6N** -> **Ingreso Disponible Neto:** El saldo final que queda en manos de los hogares para consumo o ahorro, una vez que se han restado los impuestos y añadido las prestaciones sociales.

  * **B7N** -> **Ahorro Neto:** La porción del Ingreso Disponible que no se consume. Es la diferencia entre el Ingreso Disponible y el Gasto en Consumo Final.

  * **D1** -> **Remuneración de los Asalariados:** El total de salarios y cotizaciones sociales pagadas por los empleadores. Es un componente clave del Ingreso Primario.

  * **D4** -> **Rentas de la Propiedad:** Ingresos recibidos de la propiedad de activos (intereses, dividendos, rentas de la tierra, etc.).
  
    * **D5** -> **Impuestos Corrientes sobre la Renta y el Patrimonio:** Impuestos obligatorios que los hogares pagan sobre sus ingresos o sus activos.

  * **D61** -> **Cotizaciones Sociales Netas:** Contribuciones pagadas a la seguridad social, ajustadas para reflejar las cuentas netas.

  * **D62** -> **Prestaciones Sociales Distintas de las Transferencias Sociales en Especie:** Los beneficios que los hogares reciben del Estado (pensiones, prestaciones por desempleo, etc.) en forma de dinero.

  * **D63** -> **Transferencias Sociales en Especie:** Bienes y servicios proporcionados gratuitamente o a precios bajos por el Estado (como servicios de salud o educación).

  * **D7** -> **Otras Transferencias Corrientes:** Partidas residuales de transferencias monetarias no clasificadas en las anteriores categorías.

  * **B2A3N** -> **Excedente Bruto de Explotación y Renta Mixta:** El beneficio derivado de las actividades de producción, en el contexto de los hogares suele referirse al **ingreso de los trabajadores autónomos** (renta mixta).

  * **P3** -> **Gasto en Consumo Final:** El valor de los bienes y servicios utilizados por los hogares para la satisfacción directa de sus necesidades.

  * **P51C** -> **Formación Bruta de Capital Fijo:** La inversión en activos fijos (viviendas, maquinaria, etc.) por parte del sector de los hogares.

<br>

**Región Geográfica** (`geo`) -> Define la región geográfica a la que se refiere la observación, utilizando la Nomenclatura Común de Unidades Territoriales de Estadística (NUTS).

* **Valores:** Los valores son códigos alfanuméricos estandarizados:

    * **Códigos de dos letras (e.g., AT, BE, ES):** Representan el **total del país** (ejemplo, Austria, Bélgica, España).
    
    * **Códigos NUTS 1, NUTS 2 y NUTS 3 (e.g., AT1, AT11, AT111):** Representan el desglose regional de los datos. **NUTS 2** es el nivel predominante en este *dataset* (por ejemplo, Comunidades Autónomas, grandes regiones).

<br>

Las observaciones (variables no categóricas) con valor numérico que aparecen en este dataset son:


**Fecha de la observación** (`TIME_PERIOD`) -> Esta variable especifica el **punto temporal** al que se refiere el valor registrado. En un *dataset* con frecuencia **Anual** (`freq = "A"`), esta columna contendrá el año de la observación, en este caso, tomada el primer día del año.


<br>

**Valor de la observación** (`values`) -> Esta es la **variable numérica principal** que contiene la medida estadística de interés.

  * **Función:** Es el resultado de la observación. La cifra registrada en esta columna solo puede interpretarse     correctamente al considerar las demás dimensiones:
    * **Qué se mide** (`na_item`): Por ejemplo, si es Ingreso Disponible Neto (`B6N`).
    * **En qué unidad** (`unit`): Por ejemplo, si está en Euros por habitante (`EUR_HAB`).
    * **Dónde** (`geo`): La región NUTS 2.
    * **Cuándo** (`TIME_PERIOD`): El año de la medición.
    

```{r}
# CÓDIGOS NUTS DE REGIONES REALES PRESENTES EN LOS MAPAS NUTS ACTUALES

NUTS 0_codes <- c("EL", "ES", "FI", "FR", "HR", "HU", "IE", "IS", "AL", "AT", "BA", "BE", "BG", "CH", "CY", "CZ", "DE", "DK", "EE", "IT", "LI", "LT", "LU", "LV", "ME", "MK", "MT", "NL", "NO", "PL", "PT", "RO", "RS", "SE", "SI", "SK", "TR", "UA", "XK")

NUTS1_codes <- c("DEA", "DEB", "DEC", "DED", "DEE", "DEF", "DEG", "DK0", "EE0", "EL3", "EL4", "EL5", "EL6", "ES1", "ES2", "ES3", "ES4", "ES5", "ES6", "ES7", "FI1", "AL0", "AT1", "AT2", "AT3", "BA0", "BE1", "BE2", "BE3", "BG3", "BG4", "CH0", "CY0", "CZ0", "DE1", "DE2", "DE3", "DE4", "DE5", "DE6", "DE7", "DE8", "DE9", "HR0", "HU1", "HU2", "HU3", "IE0", "IS0", "ITC", "ITF", "ITG", "ITH", "ITI", "LI0", "XK0", "LT0", "LU0", "LV0", "ME0", "MK0", "MT0", "NL1", "NL2", "NL3", "NL4", "NO0", "PL2", "PL4", "PL5", "PL6", "PL7", "PL8", "PL9", "PT1", "PT2", "PT3", "RO1", "RO2", "RO3", "RO4", "RS1", "RS2", "SE1", "SE2", "SE3", "SI0", "SK0", "TR1", "TR2", "TR3", "TR4", "TR5", "TR6", "TR7", "TR8", "TR9", "TRA", "TRB", "TRC", "FI2", "FR1", "FRB", "FRC", "FRD", "FRE", "FRF", "FRG", "FRH", "FRI", "FRJ", "FRK", "FRL", "FRM", "FRY")

NUTS 2_codes <- c("DE12", "DE13", "DE14", "DE21", "DE22", "DE23", "DE24", "DE25", "DE26", "DE27", "DE30", "DE40", "DE50", "DE60", "DE71", "DE72", "DE73", "DE80", "DE91", "DE92", "DE93", "DE94", "DEA1", "DEA2", "DEA3", "DEA4", "DEA5", "DEB1", "DEB2", "DEB3", "DEC0", "DED2", "DED4", "DED5", "DEE0", "DEF0", "DEG0", "DK01", "AL01", "AL02", "AL03", "AT11", "AT12", "AT13", "AT21", "AT22", "AT31", "AT32", "AT33", "AT34", "BA01", "BA02", "BA03", "BE10", "BE21","BE22", "BE23", "BE24", "BE25", "BE31", "BE32", "BE33", "BE34", "BE35", "BG31", "BG32", "BG33", "BG34", "BG41", "BG42", "CH01", "CH02", "CH03", "CH04", "CH05", "CH06", "CH07", "CY00", "CZ01", "CZ02", "CZ03", "CZ04", "CZ05", "CZ06", "CZ07", "CZ08", "DE11", "MK00", "MT00", "NL11", "NL12", "NL13", "NL21", "NL22", "NL23", "NL32", "NL34", "NL35", "NL36", "NL41", "NL42", "NO02", "NO06", "NO07", "NO08", "NO09", "NO0A", "NO0B", "PL21", "PL22", "PL41", "PL42", "PL43", "PL51", "PL52", "PL61", "PL62", "PL63", "PL71", "PL72", "PL81", "PL82", "PL84", "PL91", "PL92", "PT11", "PT15", "PT19", "PT1A", "PT1B", "PT1C", "DK02", "DK03", "DK04", "DK05", "EE00", "EL30", "EL41", "EL42", "EL43", "EL51", "EL52", "EL53", "EL54", "EL61", "EL62", "EL63", "EL64", "EL65", "ES11", "ES12", "ES13", "ES21", "ES22", "ES23", "ES24", "ES30", "ES41", "ES42", "ES43", "ES51", "ES52", "ES53", "ES61", "ES62", "ES63", "ES64", "ES70", "FI19", "FI1B", "FI1C", "FI1D", "FI20", "FR10", "FRB0", "FRC1", "FRC2", "FRD1", "FRD2", "FRE1", "FRE2", "FRF1", "FRF2", "FRF3", "FRG0", "FRH0", "FRI1", "FRI2", "FRI3", "FRJ1", "FRJ2", "FRK1", "FRK2", "FRL0", "FRM0", "FRY1", "FRY2", "FRY3", "FRY4", "FRY5", "HR02", "HR03", "HR05", "HR06", "HU11", "HU12", "HU21", "HU22", "HU23", "HU31", "HU32", "HU33", "IE04", "IE05", "IE06", "IS00", "ITC1", "ITC2", "ITC3", "ITC4", "ITF1", "ITF2", "ITF3", "ITF4", "ITF5", "ITF6", "ITG1", "ITG2", "ITH1", "ITH2", "ITH3", "ITH4", "ITH5", "ITI1", "ITI2", "ITI3", "ITI4", "LI00", "LT01", "LT02", "LU00", "LV00", "ME00", "SE33", "SI03", "SI04", "SK01", "SK02", "SK03", "SK04", "TR10", "TR21", "TR22", "TR31", "TR32", "TR33", "TR41", "TR42", "TR51", "TR52", "TR61", "TR62", "TR63", "TR71", "TR72", "TR81", "TR82", "TR83", "TR90", "TRA1", "TRA2", "TRB1", "TRB2", "TRC1", "TRC2", "TRC3", "XK00", "PT1D", "PT20", "PT30", "RO11", "RO12", "RO21", "RO22", "RO31", "RO32", "RO41", "RO42", "RS11", "RS12", "RS21", "RS22", "SE11", "SE12", "SE21", "SE22", "SE23", "SE31", "SE32")

NUTS3_codes <- c("AT333", "AT334", "AT335", "AT341", "AT342", "BE100", "BE211", "BE212", "BE213", "BE223", "BE224", "BE225", "BE231", "BE232", "BE233", "BE234", "BE235", "BE236", "BE241", "BE242", "BE251", "BE252", "BE253", "BE254", "BE255", "BE256", "BE257", "BE258", "BE310", "BE323", "BE328","BE329", "BE32A", "BE32B", "BE32C", "BE32D", "BE331", "BE332", "BE334", "BE335", "BE336", "BE341", "BE342", "BE343", "BE344", "BE345", "BE351", "BE352", "BE353", "BG311", "BG312", "BG313", "BG314", "BG315", "BG321", "BG322", "BG323", "BG324", "BG325", "BG331", "BG332", "BG333", "BG334", "BG341", "BG342", "BG343", "BG344", "BG411", "BG412", "BG413", "BG414", "BG415", "BG421", "BG422", "BG423", "BG424", "BG425", "CH011", "CH012", "CH013", "CH021", "CH022", "CH023", "CH024", "CH025", "CH031", "CH032", "CH033", "CH040", "CH051", "CH052", "CH053", "CH054", "CH055", "CH056", "CH057", "CH061", "CH062", "CH063", "CH064", "CH065", "CH066", "CH070", "CY000", "CZ010", "CZ020", "CZ031", "CZ032", "CZ041", "CZ042", "CZ051", "CZ052", "CZ053", "CZ063", "CZ064", "CZ071", "CZ072", "CZ080", "DE111", "DE112", "DE113", "DE114", "DE115", "DE116", "DE117", "DE118", "DE119", "DE11A", "DE11B", "DE11C", "DE11D", "DE121", "DE122", "DE123", "DE124", "DE125", "DE126", "DE127", "DE128", "DE129", "DE12A", "DE12B", "DE12C", "DE131", "DE132", "DE133", "DE134", "DE135", "DE136", "DE137", "DE138", "DE139", "DE13A", "DE141", "DE142", "DE143", "DE144", "DE145", "DE146", "DE147", "DE148", "DE149", "DE211", "DE212", "AL011", "AL012", "AL013", "AL014", "AL015", "AL021", "AL022", "AL031", "AL032", "AL033", "AL034", "AL035", "AT111", "AT112", "AT113", "AT121", "AT122", "AT123", "AT124", "AT125", "AT126", "AT127", "AT130", "AT211", "AT212", "AT213", "AT221", "AT222", "AT223", "AT224", "AT225", "AT226", "AT311", "AT312", "AT313", "AT314", "AT315", "AT321", "AT322", "AT323", "AT331", "AT332", "DE238", "DE239")

NUTS3_codes <-c(NUTS3_codes, "DE23A", "DE241", "DE242", "DE243", "DE244", "DE245", "DE246", "DE247", "DE248", "DE249", "DE24A", "DE24B", "DE24C", "DE24D", "DE251", "DE252", "DE253", "DE254", "DE255", "DE256", "DE257", "DE258", "DE259", "DE25A", "DE25B", "DE25C", "DE261", "DE262", "DE263", "DE264", "DE265", "DE266", "DE267", "DE268", "DE269", "DE26A", "DE26B", "DEA5C", "DEB11", "DEB12", "DEB13", "DEB14", "DEB15", "DEB17", "DEB18", "DEB1A", "DEB1B", "DEB1C", "DEB1D", "DEB21", "DEB22", "DEB23", "DEB24", "DEB25", "DEB31", "DEB32", "DEB33", "DEB34", "DEB35", "DEB36", "DEB37", "DEB38", "DEB39", "DEB3A", "DEB3B", "DEB3C", "DEB3D", "DEB3E", "DEB3F", "DEB3G", "DEB3H", "DEB3I", "DEB3J", "DEB3K", "DEC01", "DEC02", "DEC03", "DEC04", "DEC05", "DEC06", "DED21", "DED2C", "DED2D", "DED2E", "DED2F", "DED41", "DED42", "DED43", "DED44", "DED45", "DED51", "DED52", "DED53", "DEE01", "DEE02", "DEE03", "DEE04", "DEE05", "DEE06", "DEE07", "DEE08", "DEE09", "DEE0A", "DEE0B", "DEE0C", "DEE0D", "DEE0E", "DEF01", "DEF02", "DEF03", "DEF04", "DEF05", "DEF06", "DEF07", "DEF08", "DEF09", "DEF0A", "DEF0B", "DEF0C", "DEF0D", "DEF0E", "DEF0F", "DEG01", "DEG02", "DE26C", "DE271", "DE272", "DE273", "DE274", "DE275", "DE276", "DE277", "DE278", "DE279", "DE27A", "DE27B", "DE27C", "DE27D", "DE27E", "DE300", "DE401", "DE402", "DE403", "DE404", "DE405", "DE406", "DE407", "DE408", "DE409", "DE40A", "DE40B", "DE40C", "DE40D", "DE40E", "DE40F", "DE40G", "DE40H", "DE40I", "DE501", "DE502", "DE600", "DE711", "DE712", "DE713", "DE714", "DE715", "DE716", "DE717", "DE718", "DE719", "DE71A", "DE71B", "DE71C", "DE71D", "DE71E", "DE721", "DE722", "DE723", "DE724", "DE725", "DE731", "DE732", "DE733", "DE734", "DE735", "DE736", "DE737", "DE803", "DE804", "DE80J", "DE80K", "DE80L", "DE80M", "DE80N", "DE80O", "DE911", "DE912", "DE913", "DE914", "DE916", "DE917", "DE918", "DE91A", "DE91B", "DE91C", "DE922", "DE923", "DE925", "DE926", "DE927", "DE928", "DE929", "DE931", "DE932", "DE933", "DE934", "DE935", "DE936", "DE937", "DE938", "DE939", "DE93A", "DE93B", "DE941", "DE942", "DE943", "DE944", "DE945", "DE946", "DE947", "DE948", "DE949", "DE94A", "DE94B", "DE94C", "DE94D")

NUTS3_codes <-c(NUTS3_codes, "DE94E", "DE94F", "DE94G", "DE94H", "DEA11", "DEA12", "DEA13", "DEA14", "DEA15", "DEA16", "DEA17", "DEA18", "DEA19", "DEA1A", "DEA1B", "DEA1C", "DEA1D", "DEA1E", "DEA1F", "DEA22", "DEA23", "DEA24", "DEA26", "DEA27", "DEA28", "DEA29", "DEA2A", "DEA2B", "DEA2C", "DEA2D", "DEA31", "DEA32", "DEA33", "DEA34", "DEA35", "DEA36", "DEA37", "DEA38", "DEA41", "DEA42", "DEA43", "DEA44", "DEA45", "DEA46", "DEA47", "DEA51", "DEA52", "DEA53", "DEA54", "DEA55", "DEA56", "DEA57", "DEA58", "DEA59", "DEA5A", "DEA5B", "DE213", "DE214", "DE215", "DE216", "DE217", "DE218", "DE219", "DE21A", "DE21B", "DE21C", "DE21D", "DE21E", "DE21F", "DE21G", "DE21H", "DE21I", "DE21J", "DE21K", "DE21L", "DE21M", "DE21N", "DE221", "DE222", "DE223", "DE224", "DE225", "DE226", "DE227", "DE228", "DE229", "DE22A", "DE22B", "DE22C", "DE231", "DE232", "DE233", "DE234", "DE235", "DE236", "DE237", "FRD11", "FRD12", "FRD13", "FRD21", "FRD22", "FRE11", "FRE12", "FRE21", "FRE22", "FRE23", "FRF11", "FRF12", "FRF21", "FRF22", "FRF23", "FRF24", "FRF31", "FRF32", "FRF33", "FRF34", "FRG01", "FRG02", "FRG03", "FRG04", "FRG05", "FRH01", "FRH02", "FRH03", "FRH04", "FRI11", "FRI12", "FRI13", "FRI14", "FRI15", "FRI21", "FRI22", "FRI23", "FRI31", "FRI32", "FRI33", "FRI34", "FRJ11", "FRJ12", "FRJ13", "FRJ14", "FRJ15", "FRJ21", "FRJ22", "FRJ23", "FRJ24", "FRJ25", "FRJ26", "FRJ27", "FRJ28", "FRK11", "FRK12", "FRK13", "FRK14", "FRK21", "FRK22", "FRK23", "FRK24", "FRK25", "FRK26", "FRK27", "FRK28", "FRL01", "FRL02", "FRL03", "FRL04", "FRL05", "FRL06", "FRM01", "FRM02", "FRY10", "FRY20", "DEG03", "DEG05", "DEG06", "DEG07", "DEG09", "DEG0A", "DEG0C", "DEG0D", "DEG0E", "DEG0G", "DEG0J", "DEG0K", "DEG0L", "DEG0M", "DEG0Q", "DEG0R", "DEG0S", "DEG0T", "DEG0U", "DEG0V", "DK011", "DK012", "DK013", "DK014", "DK021", "DK022", "DK031", "DK032", "DK041", "DK042", "DK050", "EE001", "EE004", "EE008", "EE009", "EE00A", "EL301", "EL302", "EL303", "EL304", "EL305", "EL306", "EL307", "EL411", "EL412", "EL413", "EL421", "EL422", "EL431", "EL432", "EL433", "EL434", "EL511", "EL512", "EL513", "EL514", "EL515", "EL521", "EL522", "EL523", "EL524", "EL525", "EL526", "EL527")

NUTS3_codes <-c(NUTS3_codes, "EL531", "EL532", "EL533", "EL541", "EL542", "EL543", "EL611", "EL612", "EL613", "EL621", "EL622", "EL623", "EL624", "EL631", "EL632", "EL633", "EL641", "EL642", "EL643", "EL644", "EL645", "EL651", "EL652", "EL653", "ES111", "ES112", "ES113", "ES114", "ES120", "ES130", "ES211", "ES212", "ES213", "ES220", "ES230", "ES241", "ES242", "ES243", "ES300", "ES411", "ES412", "ES413", "ES414", "ES415", "ES416", "ES417", "ES418", "ES419", "ES421", "ES422", "ES423", "ES424", "ES425", "ES431", "ES432", "ES511", "ES512", "ES513", "ES514", "ES521", "ES522", "ES523", "ES531", "ES532", "ES533", "ES611", "ES612", "ES613", "ES614", "ES615", "ES616", "ES617", "ES618", "ES620", "ES630", "ES640", "ES703", "ES704", "ES705", "ES706", "ES707", "ES708", "ES709", "FI196", "FI198", "FI199", "FI19A", "FI19B", "FI1B1", "FI1C1", "FI1C2", "FI1C5", "FI1C6", "FI1C7", "FI1D5", "FI1D7", "FI1D8", "FI1D9", "FI1DA", "FI1DB", "FI1DC", "FI200", "FR101", "FR102", "FR103", "FR104", "FR105", "FR106", "FR107", "FR108", "FRB01", "FRB02", "FRB03", "FRB04", "FRB05", "FRB06", "FRC11", "FRC12", "FRC13", "FRC14", "FRC21", "FRC22", "FRC23", "FRC24", "HU313", "HU321", "HU322", "HU323", "HU331", "HU332", "HU333", "IE041", "IE042", "IE051", "IE052", "IE053", "IE061", "IE062", "IE063", "IS001", "IS002", "ITC11", "ITC12", "ITC13", "ITC14", "ITC15", "ITC16", "ITC17", "ITC18", "ITC20", "ITC31", "ITC32", "ITC33", "ITC34", "ITC41", "ITC42", "ITC43", "ITC44", "ITC46", "ITC47", "ITC48", "ITC49", "NL415", "NL416", "NL421", "NL422", "NL423", "NO020", "NO060", "NO071", "NO072", "NO073", "NO081", "NO083", "NO084", "NO085", "NO092", "NO093", "NO094", "NO0A1", "NO0A2", "NO0A3", "NO0B1", "NO0B2", "PL213", "PL214", "PL217", "PL218", "PL219", "PL21A", "PL224", "PL225", "PL227", "PL228", "PL229", "PL22A", "PL22B", "PL22C", "PL411", "PL414", "PL415", "PL416", "PL417", "PL418", "PL424", "PL426", "PL427", "PL428", "PL431", "PL432", "PL514", "PL515", "PL516", "PL517", "PL518", "PL523", "PL524", "PL613", "PL616", "PL617", "PL618", "PL619", "PL621", "PL622", "PL623", "PL633", "PL634", "PL636", "PL637", "PL638", "PL711", "PL712", "ITC4A", "ITC4B", "ITC4C", "ITC4D")

NUTS3_codes <-c(NUTS3_codes, "ITF11", "ITF12", "ITF13", "ITF14", "ITF21", "ITF22", "ITF31", "ITF32", "ITF33", "ITF34", "ITF35", "ITF43", "ITF44", "ITF45", "ITF46", "ITF47", "ITF48", "ITF51", "ITF52", "ITF61", "ITF62", "ITF63", "ITF64", "ITF65", "ITG11", "ITG12", "ITG13", "ITG14", "ITG15", "ITG16", "ITG17", "ITG18", "ITG19", "ITG2D", "ITG2E", "ITG2F", "ITG2G", "ITG2H", "ITH10", "ITH20", "ITH31", "ITH32", "ITH33", "ITH34", "ITH35", "ITH36", "ITH37", "ITH41", "ITH42", "ITH43", "ITH44", "ITH51", "ITH52", "ITH53", "ITH54", "ITH55", "ITH56", "ITH57", "ITH58", "ITH59", "ITI11", "ITI12", "ITI13", "ITI14", "ITI15", "ITI16", "ITI17", "ITI18", "ITI19", "ITI1A", "ITI21", "ITI22", "ITI31", "ITI32", "ITI33", "ITI34", "ITI35", "ITI41", "ITI42", "ITI43", "ITI44", "ITI45", "LI000", "LT011", "LT021", "LT022", "LT023", "LT024", "LT025", "LT026", "LT027", "LT028", "LT029", "LU000", "LV005", "LV009", "LV00A", "LV00B", "LV00C", "ME000", "MK001", "MK002", "MK003", "MK004", "MK005", "MK006", "MK007", "MK008", "MT001", "MT002", "NL112", "NL114", "NL115", "NL126", "NL127", "NL128", "NL131", "NL132", "NL133", "NL211", "NL212", "NL213", "NL221", "NL224", "NL225", "NL226", "NL230", "NL321", "NL323", "NL325", "NL327", "NL328", "NL32A", "NL32B", "NL341", "NL342", "NL350", "NL361", "NL362", "NL363", "NL364", "NL365", "NL366", "NL411", "NL414", "FRY30", "FRY40", "FRY50", "HR021", "HR022", "HR023", "HR024", "HR025", "HR026", "HR027", "HR028", "HR031", "HR032", "HR033", "HR034", "HR035", "HR036", "HR037", "HR050", "HR061", "HR062", "HR063", "HR064", "HR065", "HU110", "HU120", "HU211", "HU212", "HU213", "HU221", "HU222", "HU223", "HU231", "HU232", "HU233", "HU311", "HU312", "TR412", "TR413", "TR421", "TR422", "TR423", "TR424", "TR425", "TR510", "TR521", "TR522", "TR611", "TR612", "TR613", "TR621", "TR622", "TR631", "TR632", "TR633", "TR711", "TR712", "TR713", "TR714", "TR715", "TR721")

NUTS3_codes <-c(NUTS3_codes, "TR722", "TR723", "TR811", "TR812", "TR813", "TR821", "TR822", "TR823", "TR831", "TR832", "TR833", "TR834", "TR901", "TR902", "TR903", "TR904", "TR905", "TR906", "TRA11", "TRA12", "TRA13", "TRA21", "TRA22", "TRA23", "TRA24", "TRB11", "TRB12", "TRB13", "TRB14", "TRB21", "TRB22", "TRB23", "TRB24", "TRC11", "TRC12", "TRC13", "TRC21", "TRC22", "TRC31", "TRC32", "TRC33", "TRC34", "PL713", "PL714", "PL715", "PL721", "PL722", "PL811", "PL812", "PL814", "PL815", "PL821", "PL822", "PL823", "PL824", "PL841", "PL842", "PL843", "PL911", "PL912", "PL913", "PL921", "PL922", "PL923", "PL924", "PL925", "PL926", "PT111", "PT112", "PT119", "PT11A", "PT11B", "PT11C", "PT11D", "PT11E", "PT150", "PT191", "PT192", "PT193", "PT194", "PT195", "PT196", "PT1A0", "PT1B0", "PT1C1", "PT1C2", "PT1C3", "PT1C4", "PT1D1", "PT1D2", "PT1D3", "PT200", "PT300", "RO111", "RO112", "RO113", "RO114", "RO115", "RO116", "RO121", "RO122", "RO123", "RO124", "RO125", "RO126", "RO211", "RO212", "RO213", "RO214", "RO215", "RO216", "RO221", "RO222", "RO223", "RO224", "RO225", "RO226", "RO311", "RO312", "RO313", "RO314", "RO315", "RO316", "RO317", "RO321", "RO322", "RO411", "RO412", "RO413", "RO414", "RO415", "RO421", "RO422", "RO423", "RO424", "RS110", "RS121", "RS122", "RS123", "RS124", "RS125", "RS126", "RS127", "RS211", "RS212", "RS213", "RS214", "RS215", "RS216", "RS217", "RS218", "RS221", "RS222", "RS223", "RS224", "RS225", "RS226", "RS227", "RS228", "RS229", "SE110", "SE121", "SE122", "SE123", "SE124", "SE125", "SE211", "SE212", "SE213", "SE214", "SE221", "SE224", "SE231", "SE232", "SE311", "SE312", "SE313", "SE321", "SE322", "SE331", "SE332", "SI031", "SI032", "SI033", "SI034", "SI035", "SI036", "SI037", "SI038", "SI041", "SI042", "SI043", "SI044", "SK010", "SK021", "SK022", "SK023", "SK031", "SK032", "SK041", "SK042", "TR100", "TR211", "TR212", "TR213", "TR221", "TR222", "TR310", "TR321", "TR322", "TR323", "TR331", "TR332", "TR333", "TR334", "TR411", "XK001", "XK002", "XK003", "XK004", "XK005", "XK006", "XK007")

NUTS.computation <- function(s){
  if(substr(s,1,2) %in% c("EU","EA","EF","CC","OE","G2","G7"))  return(s)
  if(nchar(s)==2 & s %in% NUTS 0_codes) return("0")
  if(nchar(s)==3 & s %in% NUTS1_codes) return("1")
  if(nchar(s)==4 & s %in% NUTS 2_codes) return("2")
  if(nchar(s)==5 & s %in% NUTS3_codes) return("3")
  return("OTHERS")
}
```


```{r}
for(col in colnames(data)){
  if(is.numeric(data[[col]])) next
  if(col=="TIME_PERIOD"){
    # print(col)
    # print(
    #   paste0("data.start: ",min(data[[col]]),
    #          ", data.end: ",max(data[[col]]),
    #          ", Number of time periods: ",length(unique(data[[col]]))
    #   )
    # )
    
    cat("\nCOLUMNA: TIME_PERIOD \n")
    print(
      data %>%
        group_by(TIME_PERIOD) %>%
        summarise(N.observ=dplyr::n())%>%
        as.matrix() %>%
        noquote()
    )
    next
  }
 if(col=="geo"){
    cat("\nCONTABILIZACIÓN Nº REGIONES NUTS A PARTIR DE LA COLUMNA geo\n")
    print(
      tibble(
        NUTS=sapply(unique(data[[col]]),NUTS.computation)
      ) %>%
        group_by(NUTS) %>%
        summarise(`Number of Regions`=dplyr::n()) %>%
        as.matrix() %>%
        noquote()
    )
    next
 }
  tb <-  data %>%
    left_join(get_eurostat_dic(col)%>%rename(!!col := code_name),
              by=col) %>%
    group_by(!!sym(col),full_name)%>%
    summarise(N.Observ=dplyr::n()) %>%
    relocate(N.Observ,.before = full_name)%>%
    arrange(desc(N.Observ)) %>%
    mutate(full_name=ifelse(nchar(full_name)<41,full_name,paste0(substr(full_name,1,40),"..")))
    
  texto <- paste0("COLUMNA: ",col)
  if(nrow(tb)>50){
    texto <- paste0(texto," (",nrow(tb)," opciones, se imprimen 50)")
    tb <- head(tb,50)
  }
  cat(texto,"\n")
  
  tb %>% 
    as.matrix() %>%
    noquote() %>%
    print()
}

```
### Estructura de los datos

El dataset (`nama_10r_2hhinc`) se presenta en una estructura **ordenada** (*tidy*). Esta organización se define porque **cada fila representa una única observación**. Es decir, la combinación de las variables categóricas (`geo`, `na_item`, `unit`, etc.) y la variable temporal (`TIME_PERIOD`) define de forma unívoca la medición. El resultado de esta medición se almacena en una sola columna numérica (`values`). Este formato, también conocido como "formato largo," es el más eficiente y recomendado para la manipulación y el análisis directo de datos en entornos de software estadístico como R.

```{r}
str(data)
```


### Series temporales

El tamaño máximo de las series temporales es 29 y se cumplen los requisitos de longitud de series temporales. Tenemos datos desde el año 1995 hasta 2023, pero en especial, la mayor cantidad de observaciones se da entre los años 2000 y 2022.

```{r}
vars <- colnames(data)[1:(ncol(data)-2)]

data.series <- data %>%
  group_by(across(all_of(vars))) 

data.series.fechas <- data.series %>% 
  summarise(N.fechas=dplyr::n())
```

```{r}
percentiles <- tibble(min=min(data.series.fechas$N.fechas))
percentiles <- percentiles %>% mutate(min=min(data.series.fechas$N.fechas))
percentiles <- percentiles %>% mutate(p10=quantile(data.series.fechas$N.fechas, 0.1))
percentiles <- percentiles %>% mutate(p25=quantile(data.series.fechas$N.fechas, 0.25))
percentiles <- percentiles %>% mutate(p50=quantile(data.series.fechas$N.fechas, 0.50))
percentiles <- percentiles %>% mutate(p75=quantile(data.series.fechas$N.fechas, 0.75))
percentiles <- percentiles %>% mutate(p90=quantile(data.series.fechas$N.fechas, 0.9))
percentiles <- percentiles %>% mutate(max=max(data.series.fechas$N.fechas))

percentiles
```

### Nº observaciones

En cuanto a la distribución del número de observaciones, tenemos que `p50` = 736 y que el máximo es 1188 lo cual está bien teniendo en cuenta de que en su mayoría, este dataset tiene datos sobre regiones NUTS 2. Además, España y Canarias son regiones que son interesantes y ambas cuenta con un buen número de observaciones, 934 para ser exactos.

```{r}
data.geo <- data %>%
  group_by(geo)%>%
  summarise(N.Observ=dplyr::n())
```

**Percentiles de la distribución del nº de observaciones por regiones**
```{r}
percentiles <- tibble(min=min(data.geo$N.Observ))
percentiles <- percentiles %>% mutate(min=min(data.geo$N.Observ))
percentiles <- percentiles %>% mutate(p10=quantile(data.geo$N.Observ, 0.1))
percentiles <- percentiles %>% mutate(p25=quantile(data.geo$N.Observ, 0.25))
percentiles <- percentiles %>% mutate(p50=quantile(data.geo$N.Observ, 0.50))
percentiles <- percentiles %>% mutate(p75=quantile(data.geo$N.Observ, 0.75))
percentiles <- percentiles %>% mutate(p90=quantile(data.geo$N.Observ, 0.9))
percentiles <- percentiles %>% mutate(max=max(data.geo$N.Observ))

percentiles
```

**Nº de observaciones en España/Canarias**
```{r}
LocalRegionsFullNames <- c("Spain","Canarias","Canarias","El Hierro","Fuerteventura","Gran Canaria",
  "La Gomera","La Palma","Lanzarote","Tenerife")

LocalRegionsCodes <- c("ES","ES7","ES70","ES703","ES704","ES705","ES706","ES707","ES708","ES709")

LocalRegions <- tibble(
  geo=LocalRegionsCodes,
  full_name=LocalRegionsFullNames
)

data.geo %>%
  filter(geo %in% LocalRegionsCodes) %>%
  left_join(LocalRegions,by="geo") %>%
  relocate(full_name,.after = geo)
```


### Combinaciones existentes de variables categóricas

Los datos nos proporcionan un total de 42 posibles combinaciones de las variables categóricas, cada combinación con número de observaciones por lo general cercano a 9000, aunque también vemos algunas pocas que tienen entre 1000 y 5000 observaciones.

```{r}
vars <- colnames(data)[1:(ncol(data)-3)]
vars <- vars[vars != "age"]
vars <- vars[vars != "sex"]

data.combinaciones <- data %>%
  group_by(across(all_of(vars))) 

data.combinaciones %>%
  summarise(N.observ=dplyr::n(),
            init.date=min(TIME_PERIOD),
            end.date=max(TIME_PERIOD)) %>%
  arrange(desc(N.observ)) %>% 
  print(n=50)
```

### Inconsistencias y datos faltantes

En general, hay pocas observaciones cuando se trata de unidades PPS, que son las más interesantes, además algunos indicadores cuentan con pocas observaciones para hacer un buen análisis, en muchos casos habrá que normalizar los atributos ya que también faltan bastantes datos per cápita para algunos indicadores. Sin embargo, en los casos de España y Canarias son en los que hay más observaciones.

```{r}
# pasamos las fechas a columnas de la tabla y añadimos algunos datos 
data.fechas <- data %>%
  pivot_wider(names_from = TIME_PERIOD,values_from = values,names_sort = FALSE) %>%
  #relocate(geo) %>% 
  left_join(get_eurostat_dic("geo"), join_by(geo==code_name)) %>%
  relocate(full_name,.after=geo)%>%
  mutate(NUTS=sapply(geo,NUTS.computation)) %>%
  relocate(NUTS)  %>%
  mutate(geo2=substr(geo,1,2)) %>% 
  left_join(get_eurostat_dic("geo")%>%rename(country=full_name),join_by(geo2==code_name)) %>%
  select(-geo2) %>% 
  rename(region=full_name) %>%
  relocate(country,.after = NUTS) %>%
  arrange(NUTS,country,geo)

#data.fechas
```

**Visualización España/Canarias (máximo 60 columnas y 1000 filas por región)**

```{r}
# visualización tabla para España y Canarias 
posRegion <- which(colnames(data.fechas) == "region")
Ncol <- ncol(data.fechas)
posSelect <- 1:Ncol 
if(Ncol>60) posSelect <- unique(c(1:posRegion,(Ncol-60):Ncol))

data.fechas %>%
  select(posSelect) %>% 
  filter(geo %in% LocalRegionsCodes) %>% 
  group_by(geo) %>%
  slice_head(n = 1000) %>%
  ungroup() %>% 
  relocate(region) %>% 
  datatable(
  extensions = 'FixedColumns',
  options = list(
    scrollX = TRUE,  
    scrollY = "400px", 
    paging = FALSE,     
    fixedColumns = list(leftColumns = 1) 
  ),
  class = "stripe hover nowrap",  
  rownames = FALSE  
)
```

<br>
<br>
A continuación veremos información sobre nuestro dataset secundario que incluye datos de población anual por zonas.


```{r message=FALSE, warning=FALSE, results = 'hide'}
dataset.name <- "nama_10r_3popgdp"
data <- get_eurostat(dataset.name, time_format = "date") %>%
  as_tibble() %>%
  arrange(TIME_PERIOD, geo)
```


```{r}
for(col in colnames(data)){
  if(is.numeric(data[[col]])) next
  if(col=="TIME_PERIOD"){
    # print(col)
    # print(
    #   paste0("data.start: ",min(data[[col]]),
    #          ", data.end: ",max(data[[col]]),
    #          ", Number of time periods: ",length(unique(data[[col]]))
    #   )
    # )
    
    cat("\nCOLUMNA: TIME_PERIOD \n")
    print(
      data %>%
        group_by(TIME_PERIOD) %>%
        summarise(N.observ=dplyr::n())%>%
        as.matrix() %>%
        noquote()
    )
    next
  }
 if(col=="geo"){
    cat("\nCONTABILIZACIÓN Nº REGIONES NUTS A PARTIR DE LA COLUMNA geo\n")
    print(
      tibble(
        NUTS=sapply(unique(data[[col]]),NUTS.computation)
      ) %>%
        group_by(NUTS) %>%
        summarise(`Number of Regions`=dplyr::n()) %>%
        as.matrix() %>%
        noquote()
    )
    next
 }
  tb <-  data %>%
    left_join(get_eurostat_dic(col)%>%rename(!!col := code_name),
              by=col) %>%
    group_by(!!sym(col),full_name)%>%
    summarise(N.Observ=dplyr::n()) %>%
    relocate(N.Observ,.before = full_name)%>%
    arrange(desc(N.Observ)) %>%
    mutate(full_name=ifelse(nchar(full_name)<41,full_name,paste0(substr(full_name,1,40),"..")))
    
  texto <- paste0("COLUMNA: ",col)
  if(nrow(tb)>50){
    texto <- paste0(texto," (",nrow(tb)," opciones, se imprimen 50)")
    tb <- head(tb,50)
  }
  cat(texto,"\n")
  
  tb %>% 
    as.matrix() %>%
    noquote() %>%
    print()
}

```

### Estructura de los datos

El dataset (`nama_10r_3popgdp`) se presenta en una estructura **ordenada** (*tidy*). Esta organización se define porque **cada fila representa una única observación**. Es decir, la combinación de las variables categóricas y la variable temporal (`TIME_PERIOD`) define de forma unívoca la medición. El resultado de esta medición se almacena en una sola columna numérica (`values`). Este formato, también conocido como "formato largo," es el más eficiente y recomendado para la manipulación y el análisis directo de datos en entornos de software estadístico como R.

```{r}
str(data)
```



## Preparación de los datos

### Procesado del dataset

<br>

Empezamos cargando nuestro dataset, pasamos la variable `TIME_PERIOD` a tipo 'date' y ordenamos por dicha variable y por `geo`.
```{r}
# dataset.name <- "nama_10r_2hhinc"
# data <- get_eurostat(dataset.name, time_format = 'date') %>%
  # as_tibble() %>%
  # arrange(TIME_PERIOD, geo)

data <- read.csv("nama_10r_2hhinc.csv") %>% 
  as_tibble() %>% 
  mutate(TIME_PERIOD = as.Date(TIME_PERIOD)) %>% 
  arrange(TIME_PERIOD, geo) 

```

Ahora, vamos a convertir `TIME_PERIOD` para que **únicamente nos aparezca el año**, quitando el día y el mes y además vamos a filtrar para que solo aparezcan los años **desde el 2000 hasta el 2022**, ya que son los años en los que hay más observaciones. Luego, como solo tenemos códigos de cada región y no sus nombres, vamos a añadirle una tabla que nos proporciona **todos los nombres y su información de NUTS** a partir de su código `geo`. 
```{r carga_dataset}
data <- data %>%
  mutate(TIME_PERIOD = as.numeric(format(TIME_PERIOD, "%Y"))) %>%
  filter(TIME_PERIOD > 1999 & TIME_PERIOD < 2023)

NUTS <- read_csv('http://ctim.es/AEDV/data/eurostac_real_nuts.csv')%>%
  as_tibble() 

data <- data %>%
  left_join(NUTS, by = 'geo') %>%
  relocate(full_name, freq, unit, direct, na_item, geo, TIME_PERIOD, values, .after = data$NUTS)
  
```

A continuación vamos a cargar un dataset de población que toma como población **la media de cada año**, esto es lo más correcto para normalizar datos económicos para los que no se tienen datos per cápita como sucede en nuestro caso para muchos indicadores. En cada caso que lo necesitemos, simplemente uniremos esta tabla a otra filtrada con los paises o provincias que queramos por la columna `geo` y `TIME_PERIOD` y normalizaremos los valores necesarios. Le cambiamos el nombre a la  columna `values` por `poblacion` para evitar confusiones. Eliminamos las columnas de `freq` y `unit` ya que solo tienen un valor y no nos sirven de nada, por último cambiamos el formato de fecha para que aparezca únicamente el año y lo pasamos a dato numérico.
```{r}
poblacion <- get_eurostat("nama_10r_3popgdp", time_format = 'date') %>% 
  as_tibble() %>% 
  mutate(TIME_PERIOD = as.numeric(format(TIME_PERIOD, "%Y"))) %>% 
  rename(poblacion = values) %>% 
  select(-freq, -unit)
```

### Análisis gráfico

<br>

Para este apartado y el siguiente, procederemos a hacer un breve análisis que va **desde dentro de España hacia afuera**, terminando con una visión general sobre algunos datos. Cuando analicemos las comunidades de España usaremos **euros per cápita**, ya que las unidades PPS se utilizan para hacer comparaciones de regiones diferentes donde el precio de la vida bastante diferente.

Para empezar, comenzamos viendo la evolución de uno de los indicadores económicos más importante a nivel de bienestar de la población por comunidades de España, la **renta neta en euros per cápita.**

<br>


```{r, fig.asp = 0.8}
data.es <- data %>%
  filter(na_item == "B6N" & unit == "EUR_HAB" & ((substr(geo,1,2) == "ES" & NUTS == 2) | geo == 'EU27_2020')) %>% 
  mutate(full_name = ifelse(geo == "EU27_2020", "Media UE", full_name)) %>%
  rename(Año = TIME_PERIOD,
         valores = values) %>%
  mutate(
    grupo_color = ifelse(full_name %in% c("Canarias", "Media UE"), "Canarias", "Otras Regiones"),
    full_name = forcats::fct_relevel(full_name, "Canarias", "Media UE") 
  )

data.es.plot <- ggplot(data.es, aes(x = Año,
                                    y = valores,
                                    color = grupo_color,
                                    group = full_name,
                                    text = paste("Año: ", Año,
                                                 "<br>Valores: ", valores, "€/HAB"))) +
  geom_line(linewidth = 0.8) +
  scale_color_manual(values = c("Canarias" = "red", "Otras Regiones" = "#0072B2")) +
  facet_wrap(~ full_name,
             labeller = labeller(full_name = label_wrap_gen(width = 15))) +
  theme_minimal() +
  labs(title = "Evolución de la Renta Neta por comunidad (España)",
       x = "Año", y = "Renta Neta (€/Habitante)") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  theme(panel.spacing.x = unit(1, "lines")) +
  theme(panel.spacing.y = unit(2.5, "lines")) +
  theme(legend.position = "none",
    axis.title.x = element_text(margin = margin(t = 10))) 

ggplotly(data.es.plot, tooltip = "text")
```

<br>

El análisis de la **renta neta** en España revela una tendencia alcista estructural, interrumpida únicamente por dos choques sistémicos claros: el estallido de la burbuja inmobiliaria (2008-2013) y la crisis sanitaria del COVID-19 (2020). Si bien todas las regiones comparten este ciclo, se observa una divergencia persistente: las comunidades del norte y capitalinas (**País Vasco, Navarra y Madrid**) no solo lideran el ranking, sino que muestran una recuperación más robusta tras las crisis gracias a su tejido industrial y de servicios de alto valor.

Como dato curioso, pese a la recuperación general, muchas regiones tardaron casi una década en recuperar los niveles de poder adquisitivo previos a 2008, lo que evidencia la rigidez del mercado laboral español ante las recesiones.

<br>
<hr>
<br>

Tras un primer vistazo sobre la **renta neta** en cada país, echemos un vistazo ahora a la **capacidad de ahorro neto en euros per cápita** por comunidades de España, y veamos si hay alguna similitud ya que la renta neta y la capacidad de ahorro deberían estar relacionadas. En este caso en lugar de ver una evolución, tenemos datos del último año que nos ofrece este dataset, 2022.

<br>

```{r}

data.ahorro.es <- data %>%
  filter(na_item == 'B7N', unit == 'EUR_HAB', substr(geo,1,2) == 'ES', TIME_PERIOD == max(TIME_PERIOD) & NUTS == 2) %>%
  arrange(values) 

data.ahorro.es.plot <- data.ahorro.es %>% 
  ggplot(aes(x = reorder(full_name, values), 
             y = values,
             group = full_name,
             fill = values, 
             text = paste("Región: ", full_name,
                          "<br>Valores: ", values, "€"))) +
  
  geom_col(width = 0.7, show.legend = FALSE) + 
  
  geom_col(data = . %>% filter(full_name == "Canarias"),
           fill = "red", 
           width = 0.7, 
           show.legend = FALSE) +
           
  coord_flip() +
  scale_fill_gradient(low = "#87CEEB", high = "#1A476F") + 
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 9),
    axis.text.x = element_text(size = 9),
    plot.title = element_text(size = 14, face = "bold"),
    legend.position = 'none'
  ) +
  labs(
    title = "Nivel de Ahorro Neto por comunidad (España)",
    x = NULL,
    y = "Ahorro Neto (€/Habitante)"
  ) + 
  theme_bw(base_size = 12)

ggplotly(data.ahorro.es.plot, tooltip = "text")
```

<br>

En general, los países que mejor **renta neta per cápita** presentaban son los que se encuentran más arriba en esta gráfica, como vemos, **Canarias** se sitúa bastante abajo en estos términos.

<br>
<hr>
<br>

Para confirmar que efectivamente una mayor renta neta se traduce directamente en una mayor capacidad de ahorro neto, podemos echar un vistazo a este diagrama de dispersión animado que **relaciona** estos 2 conceptos por las diferentes comunidades autónomas a lo largo de los años en euros per cápita.

<br>


```{r}
data.spain.disp <- data %>%
  filter(
    na_item %in% c("B6N", "B7N") &
    substr(geo,1,2) == 'ES' &
    NUTS == 2 &
    unit == "EUR_HAB" 
  ) %>%
  pivot_wider(names_from = na_item, values_from = values) %>% 
  rename(Año = TIME_PERIOD)


data.spain.disp.plot <- data.spain.disp %>% 
ggplot(aes(x = B6N,
           y = B7N,
           label = full_name,
           text = paste("Región: ", full_name,
                        "<br>Renta Neta: ", B6N, "€/HAB",
                        "<br>Ahorro Neto: ", B7N, "€/HAB"))) +
  geom_point(colour = "#1A476F", aes(size = 3, frame = Año)) +
  labs(
    title = "Relación entre Renta y Ahorro por comunidades (España)",
    x = "Renta Neta (€/Habitante)",
    y = "Ahorro Neto (€/Habitante)"
  ) +
  theme_minimal(base_size = 12) + 
  theme(legend.position = 'none',
        axis.title.y = element_text(margin = margin(r = 10)))

ggplotly(data.spain.disp.plot, tooltip = "text") %>% 
    animation_opts(frame = 200)

```

<br>

Como podemos ver existe una fuerte correlación entre la renta y el ahorro, en general las comunidades con mayor **renta neta** también presentan mayor **capacidad de Ahorro**. Se aprecian claramente retrocesos en los años de crisis y algo curioso es que a lo largo de los años las comunidades se alejan más unas de las otras, reflejando una mayor desigualdad en estos términos.

Las regiones como **País Vasco, Navarra y Madrid** se sitúan claramente por encima de la media nacional, mientras que **Andalucía, Extremadura o Canarias** presentan niveles más bajos tanto de renta como de ahorro.

Esto sugiere **diferencias estructurales regionales** en el poder adquisitivo y la capacidad de ahorro de los hogares.

<br>
<hr>
<br>

Con esta última conclusión de las diferencias estructurales regionales, sería interesante dividir la renta total de España entre las distintas regiones de esta (Norte, Sur, Este, Noreste, Noroeste, Centro, Madrid y Canarias) y representarlo mediante un diagrama de disco para que ver que porcentaje se lleva cada zona, antes de ver el gráfico debemos saber que comunidades se agrupan en las distintas regiones:

* **Noroeste**: Galicia, Principado de Asturias y Cantabria.

* **Noreste**: País Vasco, Comunidad Foral de Navarra, La Rioja y Aragón.

* **Comunidad de Madrid**: Comunidad de Madrid (Constituye una región única debido a su relevancia económica).

* **Centro**: Castilla y León, Castilla-La Mancha y Extremadura.

* **Este**: Cataluña, Comunidad Valenciana e Islas Baleares.

* **Sur**: Andalucía, Región de Murcia, Ceuta y Melilla.

* **Canarias**: Canarias (Constituye una región única por su carácter insular).

Tomaremos como unidad euros per cápita para que la población de cada zona no sea un factor influyente y sea una comparación efectiva.

<br>
<br>
```{r,fig.asp = 0.8}
data.spain.pie <- data %>%
filter(substr(geo,1,2) == 'ES' & NUTS == 1 & na_item == 'B6N' & unit == 'EUR_HAB' & TIME_PERIOD == max(TIME_PERIOD)) %>%
  arrange(desc(values)) %>%
  mutate(porcentaje = scales::percent(values/sum(values))) %>%
  select(full_name, values, porcentaje)

data.spain.pie %>%
  plotly::plot_ly(
    labels = ~full_name,
    values = ~values,
    
    text =  ~paste("Región: ", data.spain.pie$full_name),
    textinfo = 'percent',
    insidetextorientation='radial',
    hoverinfo = "text") %>% 
  add_pie(hole = 0.4) %>% 
  layout(
    title = list(text = "Distribución de la Renta Neta por Regiones de España")
  )



```
  
<br>

Tras analizar la gráfica de disco, vemos que efectivamente las regiones del sur de España y Canarias presentan un **menor poder adquisitivo** y por consecuente, una **menor capacidad de ahorro.** La mayor parte de la renta cae sobre **Madrid y las regiones del Noreste y Noroeste.**

<br>
<hr>
<br>

Ya que conocemos bien la renta neta que presenta cada comunidad en España, echemos un vistazo ahora a los **impuestos sobre renta y patrimonio** que se pagan en cada una, medidos en euros por habitante y representados mediante un mapa de calor. Tenemos datos desde el año 2016 hasta el 2022.

<br>

```{r, fig.asp = 0.8}
data.imp.comunidades <- data %>%
  filter(na_item == 'D5' & unit == 'MIO_EUR' & NUTS == 2 & TIME_PERIOD > 2015 & TIME_PERIOD < 2023 & substr(geo,1,2) == 'ES') %>%
  select(geo, full_name, TIME_PERIOD, values) %>%
  arrange(desc(values)) 

data.imp.comunidades <- data.imp.comunidades %>% 
  left_join(poblacion, by = c('geo', 'TIME_PERIOD')) %>%
  mutate(imp.per.capita = (values * 1000000) / (poblacion * 1000)) %>%
  arrange(desc(imp.per.capita))

data.imp.comunidades.plot <- data.imp.comunidades %>%
  ggplot(aes(x = TIME_PERIOD,
             y = full_name,
             fill=imp.per.capita,
             text = paste("Año: ", TIME_PERIOD,
                          "<br>Región: ", full_name,
                          "<br>Valores: ", round(imp.per.capita,1), "€/HAB"))) +
  geom_tile(color = "grey80") +
  scale_fill_gradient2(
    low = "#1A476F",      
    mid = "#87CEEB",      
    high = "#1A476F",      
    midpoint = 0,          
    space = "Lab",         
    name = "Impuestos"      
) + 
  labs(title="Impuestos sobre renta y patrimonio pagados (2016-2022)",
       x="Año",
       y="Comunidades (España)",
       fill = "Impuestos per cápita") + 
  theme(
    axis.title.y = element_text(margin = margin(r = 18))) + 
  theme_bw(base_size = 10)

ggplotly(data.imp.comunidades.plot, tooltip = "text")
```

<br>

El mapa de calor de **Impuestos sobre Renta y Patrimonio** per cápita entre 2016 y 2022 es, en realidad, un mapa de la riqueza regional de España. Los tonos más oscuros confirman la relación fundamental de la fiscalidad: las comunidades que más pagan son las que más generan.

**Riqueza como Causa**: Regiones como la Comunidad de Madrid, el País Vasco y Navarra muestran la mayor presión fiscal directa (azul intenso). Esto se debe a que su Renta Disponible Neta es históricamente más alta, lo que automáticamente eleva el pago del IRPF debido a su naturaleza progresiva. El alto nivel de impuestos es el resultado de una base imponible (ingresos) superior.

**Doble Medición del Impuesto**: La variación en D.5 también subraya que no solo mide la renta generada en el año:

  * El IRPF refleja los ingresos corrientes.

  * Los impuestos patrimoniales (como el IBI) reflejan la riqueza acumulada (stock). Esto explica por qué regiones con alto valor inmobiliario, como las Islas Baleares, pueden tener una alta contribución fiscal per cápita.

**Consecuencia Económica**: La intensificación general del color azul después de 2020 indica un crecimiento de la renta nominal en el país. En última instancia, esta alta contribución fiscal en las regiones líderes confirma su rol como motores económicos: a pesar de pagar los impuestos más altos, su capacidad de Ingreso y su alto Ahorro Neto (B7N) residual las identifica como los principales centros de acumulación de capital de España.
 

<br>
<hr>
<br>

Para finalizar con las comunidades de España, veamos mediante un diagrama de cajas, como se distribuyen los 3 principales indicadores económicos, **Ingreso primario neto, Renta neta y Ahorro neto** por las distintas comunidades españolas en euros por habitante.

<br>
```{r, fig.asp = 0.8}
label_mapping <- c(
  "B5N" = "Ingreso Primario Neto",
  "B6N" = "Ingreso Disponible Neto",
  "B7N" = "Ahorro Neto"
)

data.spain.box <- data %>% 
  filter(NUTS == 2 & substr(geo,1,2) == 'ES' & na_item %in% c('B5N', 'B6N', 'B7N') & unit == 'EUR_HAB') %>% 
  pivot_wider(names_from = unit, values_from = values) %>%
  mutate(
    nombre_indicador = label_mapping[na_item]
  )

data.spain.box.plot <- data.spain.box %>% 
  ggplot(aes(x = nombre_indicador, 
             y = EUR_HAB,
             fill = nombre_indicador,
             text = paste("Indicador: ",nombre_indicador,
                          "<br>Año: ",TIME_PERIOD,
                          "<br>Región: ",full_name))) +
  geom_boxplot(alpha = 0.7, color = "black", outlier.color = "red") +
  scale_fill_manual(
    values = c(
      "Ingreso Primario Neto" = "#FDAE61", 
      "Ingreso Disponible Neto" = "#2C7BB6", 
      "Ahorro Neto" = "#66BD63"
    )
  ) +
  labs(
    title = "Comparación de tipos de ingreso en regiones españolas",
    subtitle = "Distribución del euro per cápita",
    x = "Tipo de ingreso",
    y = "€ por habitante",
    fill = "Tipo de ingreso"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 13),
    legend.position = "top",
    axis.title.y = element_text(margin = margin(r = 15)), 
    axis.title.x = element_text(margin = margin(t = 15))) +
  theme_minimal() 

ggplotly(data.spain.box.plot, tooltip = 'text')
```

<br>

Como comentábamos, este gráfico muestra la distribución de los distintos tipos de ingreso por habitante en las regiones españolas. Se observa que el **ingreso primario (B5N)** es el más alto y disperso, mientras que la **renta neta (B6N)** se reduce tras impuestos y transferencias, evidenciando el efecto redistributivo. **El ahorro (B7N)** presenta mayor variabilidad, reflejando diferencias regionales en la capacidad de ahorro. Los outliers principalmente se corresponden con regiones con niveles excepcionalmente altos en estos indicadores, sobretodo Madrid y País Vasco como ya hemos visto, donde el PIB y las rentas tienden a ser más elevadas.

<br>
<hr>
<br>

```{r}
ParetoValue <- function(
v, # vector numérico
ParetoSignificancia # número en [0,1] con el grado de significancia de Pareto
){
  x <- sort(v,decreasing = TRUE)
  return(x[which(cumsum(x)>=ParetoSignificancia*sum(x))[1]])
}
```

Centrémonos ahora en **visualizar y comparar a España como país**, en este caso tendremos que usar **unidades PPS** mayoritariamente siempre que el dataset nos ofrezca datos en esta unidad, ya que estamos comparando distintos países. 

En primer lugar vamos a utilizar una función de pareto para quedarnos con los países que poseen el 80% de la renta neta de Europa entre los cuales se encuentra España y vamos a ver un gráfico de barras animado que nos muestra la evolución de esos países cada año.

<br>

```{r}
data.top.rentaPPS.pareto <- data %>%
  filter(na_item == 'B6N' & unit == 'PPS_EU27_2020_HAB' & NUTS == 0 & TIME_PERIOD == max(TIME_PERIOD)) %>%
  filter(values >= ParetoValue(values, 0.8)) %>% 
  arrange(desc(values))
  
  

data.canarias.mediaue.renta.PPS <- data %>% 
  filter(na_item == 'B6N' & unit == 'PPS_EU27_2020_HAB' & ((full_name  == 'Canarias' & NUTS == 2) | geo == 'EU27_2020')) %>% 
  mutate(full_name = ifelse(geo == 'EU27_2020', 'Media UE', full_name))


data.top.renta.PPS <- data %>% 
  filter(na_item == 'B6N', unit == 'PPS_EU27_2020_HAB', NUTS == 0, full_name %in% data.top.rentaPPS.pareto$full_name) 

data.topPPS.plot <- rbind(data.top.renta.PPS, data.canarias.mediaue.renta.PPS) %>% arrange(desc(values))



data.topPPS.plot <- data.topPPS.plot %>% 
  ggplot(aes(x = full_name, 
             y = values,
             fill = full_name)) +
  geom_bar(stat = 'identity') + 
  labs(x = "Países", y = "Renta Neta (Unidades PPS/Habitante)") +
  coord_flip() +
  theme_bw(base_size = 10) +
  theme(legend.position = "none",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 15))) +
  labs(title = "Evolución de la Renta Neta por países| Año: {current_frame}") +
  transition_manual(TIME_PERIOD)
  
animate(data.topPPS.plot, fps = 2, end_pause = 10)
```

<br>

Vemos que, en general, **España** es un país que se mueve en valores de renta cercanos a los de la media de la Unión Europea. El declive posterior a 2008 es un reflejo de la fuerte dependencia de España de sectores cíclicos (como la construcción y el turismo) y del alto desempleo estructural. Mientras que las economías industriales del norte rebotaron con relativa rapidez tras la crisis financiera, el crecimiento de la renta española se estancó. Vemos que los dos países con mejores niveles de renta neta per cápita son **Luxemburgo y Alemania**, vamos a comentar estos dos casos por separado.

**Luxemburgo es un caso atípico** que distorsiona las métricas macroeconómicas de renta per cápita, lo cual es importante para interpretar cualquier resultado:

 * **Centro Fiscal**: Gran parte de la renta contable se genera por los beneficios de empresas multinacionales y los flujos financieros que se registran en el país por motivos fiscales.

* **Efecto de Denominador**: Al ser un país pequeño, cuando estos flujos de capital se dividen por una población relativamente reducida, la cifra per cápita se dispara artificialmente, sin que este aumento refleje necesariamente el poder adquisitivo directo del trabajador promedio residente.

La alta renta alemana se sustenta en su potente base industrial y manufacturera.

  * **Valor Añadido Bruto** (VAB): El enfoque en la ingeniería, la automoción de alta gama y la química asegura que la producción nacional genere un VAB elevado.

  * **Estabilidad**: Esta estructura de exportación de bienes de capital proporciona una fuente de ingresos nacionales estable y constante, lo que se traslada a salarios altos y, por ende, a una renta disponible por habitante consistentemente superior a la media.

<br>
<hr>
<br>

Continuémos viendo la evolución económica de los países, en este caso vamos a echar un vistazo a la **evolución del ingreso primario neto**, es decir, los ingresos brutos per cápita de cada país medidos en unidades PPS. Dado que Europa tiene muchos países, en este caso mostraremos los países más interesantes a comparar con España.

Ilustraremos esto con un gráfico de líneas.

<br>

```{r}

paises.comparar <- c("Italy", "Portugal", "Greece", "Germany", "France", "Netherlands", "Luxembourg", "Ireland", "Canarias", "Sweden", "Austria", "Poland", "Czechia", "Media UE", "Spain")

datats.evolucion.ingresoprimario <- data %>% 
  mutate(full_name = ifelse(geo == 'EU27_2020', "Media UE", full_name)) %>% 
  filter(((NUTS == 0) | (geo == 'EU27_2020') | (full_name == 'Canarias' & NUTS == 2)) & na_item == 'B5N' & unit == 'PPS_EU27_2020_HAB' & full_name %in% paises.comparar) %>% 
  select(full_name, TIME_PERIOD, values) %>% 
  rename(Paises = full_name,
         Año = TIME_PERIOD,
         `Ingreso Primario Neto` = values) %>% 
  arrange(Año, `Ingreso Primario Neto`) %>% 
  as_tsibble(index = Año, key = Paises) %>% 
  fill_gaps()
```

```{r}
datats.evolucion.ingresoprimario %>% 
  hchart("line", hcaes(x = Año, y = `Ingreso Primario Neto`, group = Paises)) %>% 
  hc_title(text = "Evolución del Ingreso Primario por País") %>% 
  hc_subtitle(text = "Valores tomados en unidades PPS per cápita") 
  

```

<br>

En general con este gráfico llegamos a las mismas conclusiones que antes pero, sin embargo, este nos permite más enforcanos que valores toma España con respecto a la **media de la Unión Europea**, vemos con claridad que hasta antes de la crisis del 2008 España se situaba por encima de esta y que después de dicha crisis **no consigue recuperase de la misma manera que la media** a pesar de que la tendencia sigue siendo ascendente.


<br>
<hr>
<br>

Y bueno ya que venimos viendo la evolución del ingreso primario neto (ingreso bruto), puede ser interesante ver en cada país la **intervención del Estado sobre este ingreso primario**, es decir, **cuánto dinero pierde o gana un hogar después de que el Estado aplica impuestos y devuelve beneficios (prestaciones sociales recibidas)**, para este caso también incluiremos a **Canarias** junto con los países.

Para cuantificar y visualizar el impacto de la intervención del Estado en el ingreso de los hogares, se utiliza la Renta Disponible Neta, la cual, por definición en las cuentas nacionales, es el resultado final después de aplicar impuestos y transferencias sociales.

Es crucial entender que la Renta Disponible Neta ya incorpora las prestaciones sociales recibidas y otros beneficios, y por tanto, no es necesario incluirlas en la fórmula de cálculo.

 * Si el resultado es **POSITIVO** (Ingreso Primario > Renta Neta): El país es un **Pagador Neto** (El Estado quita más de lo que devuelve).

 * Si el resultado es **NEGATIVO** (Ingreso Primario < Renta Neta): El país es un **Receptor Neto** (El Estado devuelve más de lo que quita).
 
 <br>
```{r}

data.diff.paises <- data %>% 
  filter(((NUTS == 0) | (full_name == 'Canarias' & NUTS == 2)) & na_item %in% c("B5N", "B6N"), unit == 'MIO_EUR', TIME_PERIOD == max(TIME_PERIOD)) %>%
  select(-direct) %>% 
  left_join(poblacion, by = c('geo', 'TIME_PERIOD')) %>% 
  mutate(per.capita = (values * 1000000) / (poblacion * 1000)) %>% 
  select(-values) %>% 
  rename(values = per.capita) %>% 
  pivot_wider(names_from = na_item, values_from = values) %>% 
  mutate(Diferencia = B5N - B6N) %>% 
  rename(Región = full_name,
         Año = TIME_PERIOD,
         `Ingreso primario neto` = B5N,
         `Renta neta` = B6N) %>% 
  select(Región, Año, `Ingreso primario neto`, `Renta neta`, Diferencia)


```

```{r, fig.asp = 0.7}
p_diferencia <- data.diff.paises %>%
  ggplot(aes(x = reorder(Región, Diferencia), 
             y = Diferencia,
             fill = Diferencia,
             text = paste("Región:", Región,
                          "<br>Impacto Neto:", round(Diferencia, 1), "€/HAB"))) +
  geom_col() +
  coord_flip() + 
  scale_fill_gradient2(
      low = "#3366CC",       
      mid = "#ADD8E6",         
      high = "#DC3912",      
      midpoint = 0,          
      labels = scales::comma 
  ) +
  geom_hline(yintercept = 0, color = "black", linewidth = 0.8) + 
  labs(title = "Efecto Neto de la Redistribución Fiscal",
       x = "",
       y = "Países",
       fill = "Efecto Neto (€/Habitante)") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom",
    axis.title.y = element_text(margin = margin(r = 10))) + 
  theme_bw(base_size = 12)

ggplotly(p_diferencia, tooltip = "text")
```

<br>

El gráfico de Efecto Neto de la Redistribución Fiscal muestra una clara y pronunciada polarización económica en Europa, revelando la diferencia entre el **Ingreso Primario** y la **Renta Disponible.**

El resultado evidencia que las economías se dividen en dos grandes grupos:

* **Pagadores Netos (Contribuyentes):** Los países del Norte y Centro de Europa (Dinamarca, Países Bajos, Luxemburgo y Alemania) son los mayores contribuyentes netos, con un hogar promedio que cede entre 8.000€ y 10.000€ al Estado después de impuestos y transferencias. Esta fuerte presión fiscal refleja la financiación de robustos Estados de Bienestar y la alta recaudación.

* **Receptores Netos (Asistencia):** En contraste, las economías del Sur y del Este de Europa (incluyendo Grecia, Polonia, Portugal, y Eslovaquia) se sitúan cerca del valor cero o son receptores netos, lo que indica que las prestaciones y transferencias sociales que reciben sus hogares son casi iguales o superiores a los impuestos que pagan.

**España** se sitúa como un contribuyente neto moderado, lejos de las cifras de cabeza, pero todavía con una contribución positiva, mientras que las regiones periféricas y más débiles (como Canarias en la lista) son, en esencia, fiscalmente neutrales.

<br>
<hr>
<br>

En la gráfica anterior, vimos el saldo final de la intervención del Estado, identificando qué países eran contribuyentes netos (Pagadores Netos) y cuáles dependían más de las ayudas sociales (Receptores Netos).

Ahora, para entender mejor la magnitud de la diferencia que genera ese saldo, nos centraremos en la salida de recursos obligatoria que soporta cada hogar.

Para calcular esta carga fiscal directa sobre el ingreso, sumamos dos componentes clave que restan directamente de la renta de las familias: los **Impuestos Corrientes sobre Renta y Patrimonio** y las **Cotizaciones Sociales Netas**. 

Este mapa de calor nos permitirá visualizar qué países y regiones tienen la mayor presión sobre el ingreso per cápita, la cual es necesaria para sostener sus respectivos sistemas de bienestar.

<br>

```{r,fig.asp = 0.8}

data.imp <- data %>%
  filter(na_item %in% c('D5', 'D61') & unit == 'MIO_EUR' & NUTS == 0, TIME_PERIOD > 2015 & TIME_PERIOD < 2023, direct == 'PAID') %>%
  select(-direct) %>% 
  pivot_wider(names_from = na_item, values_from = values) %>%
  mutate(Impuestos = D5 + D61) %>% 
  select(geo, full_name, TIME_PERIOD, Impuestos) %>%
  arrange(desc(Impuestos)) 

data.imp <- data.imp %>% 
  left_join(poblacion, by = c('geo', 'TIME_PERIOD')) %>%
  mutate(Impuestos.pagados = (Impuestos * 1000000) / (poblacion * 1000)) %>%
  arrange(desc(Impuestos.pagados))

data.imp.plot <- data.imp %>%
  ggplot(aes(x = TIME_PERIOD,
             y = full_name,
             fill=Impuestos.pagados,
             text = paste("Año: ", TIME_PERIOD,
                          "<br>Región: ", full_name,
                          "<br>Valores: ", round(Impuestos.pagados,1), "€/HAB"))) +
  geom_tile(color = "black", linewidth = 0.5) +
  scale_fill_gradient2(
    low = "#1A476F",      
    mid = "#87CEEB",      
    high = "#1A476F",      
    midpoint = 0,          
    space = "Lab",         
    name = "Presión fiscal (€/Habitante)"      
) + 
  labs(title="Presión Fiscal Directa sobre la Renta (2016-2022)",
       x="Año",
       y="Países") + 
  theme(    
    axis.title.y = element_text(margin = margin(r = 25)), 
    axis.title.x = element_text(margin = margin(t = 10)),) + 
  theme_bw(base_size = 10) 

ggplotly(data.imp.plot, tooltip = "text")
```
<br>

El mapa de calor de la **Presión Fiscal Directa** revela una nítida polarización entre la Europa del Norte y la del Este, lo cual confirma la solidez de los Estados de Bienestar en las regiones más ricas.

El análisis muestra que los países escandinavos y del Benelux (**Dinamarca, Países Bajos y Suecia**) imponen la mayor presión fiscal directa sobre el ingreso (por encima de los 20.000€ per cápita en varios casos), lo cual se debe a la financiación de sus amplios sistemas de seguridad social. En contraste, países con economías de menor escala (como Bulgaria, Croacia o Rumania) muestran la carga fiscal más baja. **España** se posiciona en un nivel intermedio-alto de contribución fiscal, lo cual es coherente con su rol como economía grande en la Eurozona.

El dato curioso es que esta visualización confirma que los países con la mayor presión fiscal (**Dinamarca, Países Bajos**) son precisamente los que resultaron ser Pagadores Netos en el análisis anterior, demostrando que la magnitud de la recaudación es la que dicta el saldo fiscal final.

<br>
<hr>
<br>

Hemos analizado la presión fiscal directa sobre el ingreso de los hogares, que es el coste necesario para financiar los sistemas de bienestar y Cotizaciones. Ahora, es el momento de examinar el resultado final de esa riqueza generada y la capacidad de inversión.

Por último, cerramos el apartado con una visión geográfica y detallada del último año de datos (2022). Usaremos dos mapas coropléticos a nivel de regiones NUTS 2 para ver cómo se distribuyen la **Renta Disponible Neta** y la **Inversión en Activos Fijos,** lo que nos permitirá extraer conclusiones específicas sobre los focos geográficos de mayor riqueza y dinamismo económico en Europa, utilizaremos unidades PPS para el caso de la Renta Neta y euros por habitante para el caso de la Inversión en Activos Fijos, ya que no tenemos datos con unidades PPS.

<br>

```{r}
geoj <- geojson_read("https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_20M_2024_4326_LEVL_0.geojson",  what = "sp")
geoj.tb <- geoj %>% 
  as_tibble() %>% 
  rename(geo = NUTS_ID)
```


```{r}
geoj2 <- geojson_read("https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_20M_2024_4326_LEVL_2.geojson", what = 'sp')

geoj2.tb <- geoj2 %>% 
  as_tibble() %>% 
  rename(geo = NUTS_ID)
```


```{r}
mapa.NUTS 2.renta <- data %>% 
  filter(NUTS == 2, na_item == "B6N", unit == "PPS_EU27_2020_HAB", TIME_PERIOD == max(TIME_PERIOD))  

mapa.NUTS 2.renta.join <- geoj2.tb %>% 
  left_join(mapa.NUTS 2.renta, by = "geo")

etiquetas <- paste( "<strong>", geoj2.tb$NUTS_NAME,
                   "</strong><br><strong>Valor: </strong>", 
                   round(mapa.NUTS 2.renta.join$values, 1), "<strong>PPS/HAB</strong>") %>% 
  lapply(htmltools::HTML)

leyenda <- "Renta neta<br>disponible"
MapaCoropléticoMemoria(geoj2, mapa.NUTS 2.renta.join$values, etiquetas, leyenda)
```
<br>

De este primer mapa podemos sacar las siguientes conclusiones:

* **El Eje Central de Riqueza:** La renta disponible más alta (tonos rojos) se concentra claramente en el eje central de Europa (el 'Arco de la Riqueza'): el sureste del Reino Unido (Londres), Benelux, el oeste y sur de Alemania (Baden-Württemberg, Baviera) y Escandinavia. Esto confirma que los países con la mayor presión fiscal directa son los que también tienen la mayor renta per cápita.

* **Disparidad Extrema:** Existe un fuerte clivaje (división) Norte-Oeste/Sur-Este. La renta cae drásticamente en todo el Sur (Italia, Portugal, Grecia) y en los países de la ampliación oriental, que están en el rango más bajo (tonos amarillos).

* **Efecto Capital:** Las capitales y los centros financieros (París, Dublín, Praga, Viena) se destacan como islas de alta renta (puntos rojos oscuros), reflejando la concentración de servicios de alto valor añadido.

* **Caso de España:** España muestra una notable disparidad intra-nacional. Mientras que regiones como Madrid y el País Vasco se sitúan en el rango medio-alto de la UE, la mayor parte del territorio, especialmente Andalucía y Extremadura, se encuentra en el rango medio-bajo, alineado con el sur de Italia. Esto confirma la disparidad estructural regional interna de España.

<br>
```{r}
mapa.NUTS 2.inversionactivos <- data %>% 
  filter(NUTS == 2, na_item == "P51C", unit == "MIO_EUR", TIME_PERIOD == max(TIME_PERIOD)) %>% 
  left_join(poblacion, by = c('geo', 'TIME_PERIOD')) %>% 
  mutate(per.capita = (values * 1000000) / (poblacion * 1000)) %>% 
  select(-values) %>% 
  rename(values = per.capita)

mapa.NUTS 2.inversionactivos.join <- geoj2.tb %>% 
  left_join(mapa.NUTS 2.inversionactivos, by = "geo")

etiquetas <- paste( "<strong>", geoj2.tb$NUTS_NAME,
                   "</strong><br><strong>Valor: </strong>", 
                   round(mapa.NUTS 2.inversionactivos.join$values, 1), "<strong>PPS/HAB</strong>") %>% 
  lapply(htmltools::HTML)

leyenda <- "Inversión en<br>activos fijos"
MapaCoropléticoMemoria(geoj2, mapa.NUTS 2.inversionactivos.join$values, etiquetas, leyenda)
```
<br>

Este segundo mapa revela que la inversión productiva se concentra en un eje muy específico de Europa Occidental y Central, que está desvinculado de la distribución de la renta disponible.

* **Foco de Capitalización:** Los niveles de inversión más altos (tonos rojos intensos) se concentran en el tradicional "Cinturón Industrial" que abarca Francia, el norte de Italia (el principal foco), y el sur de Alemania/Austria.

* **Disparidad con la Renta:** A diferencia del mapa de renta, donde Italia y Francia tenían niveles intermedios, aquí muestran la mayor intensidad de inversión. Esto sugiere que, si bien la renta disponible per cápita en estos países es menor que en Holanda o Dinamarca, el capital productivo se está inyectando con mayor fuerza en sus bases industriales.

* **Caso Español:** España y Portugal se encuentran consistentemente en el rango bajo a medio (tonos amarillos y naranjas claros), lo que indica un **atraso estructural en la inversión productiva** en comparación con el núcleo industrial de la Eurozona.

<br>
<hr>

Todas este análisis realizado en este apartado se encuentra desarrollado en mayor profundidad en el **cuadro de mandos** del proyecto, ahí se permite una mayor exploración en profundidad de las distintas variables y las distintas regiones.

## Modelado


En este apartado haremos un análisis utilizando algunos modelos matemáticos que nos permitirán realizar predicciones y medir relaciones entre las distintas variables.

Al igual que en el anterior apartado, este análisis irá desde dentro de España hacia afuera.

Empezaremos el análisis visualizando una predicción hasta 2030 de la evolución de la renta neta en euros per cápita por las diferentes Comunidades Españolas. Para una mayor precisión filtraremos a partir del año 2002 ya que fue cuando se introdujo el euro a España.

<br>
```{r}
datats.renta.spain.comunidades <- data %>% 
  filter(((NUTS == 2 & substr(geo,1,2) == 'ES') | (geo == 'EU27_2020')), unit == 'EUR_HAB', na_item == 'B6N' & TIME_PERIOD > 2001) %>% 
  mutate(full_name = ifelse(geo == 'EU27_2020', 'Media UE', full_name)) %>% 
  select(TIME_PERIOD, values, full_name) %>% 
  arrange(TIME_PERIOD) %>% 
  rename(Año = TIME_PERIOD,
         valores = values,
         Región = full_name) %>% 
  as_tsibble(index = Año, key = Región) %>%
  fill_gaps()

```


```{r, results = 'hide'}
datats.renta.spain.comunidades.arima <- datats.renta.spain.comunidades %>% 
  model(ARIMA()) 
  
```

```{r}
datats.renta.spain.comunidades.arima.pred <- datats.renta.spain.comunidades.arima %>% 
  forecast(h = 8) 

p <- datats.renta.spain.comunidades.arima.pred %>% 
  autoplot(datats.renta.spain.comunidades) + 
  theme_bw(base_size = 10) +
  facet_wrap(~Región,
             nrow = 4,           
             labeller = labeller(Región = label_wrap_gen(width = 15))) + 
  labs(x = "Año", y = "Renta neta (€/HAB)", title = "Evolución Renta Neta (Comunidades España)") +
 theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  theme(legend.position = "none") +
  theme(
    plot.margin = margin(t = 45, r = 10, b = 10, l = 10, unit = "pt"),
    plot.title = element_text(face = "bold", margin = margin(b = 60)),
    axis.title.y = element_text(margin = margin(r = 10)), 
    axis.title.x = element_text(margin = margin(t = 15)),
    strip.text = element_text(margin = margin(t = 13, r = 7, b = 10, l = 7)),
    panel.spacing.x = unit(1, "lines"), 
    panel.spacing.y = unit(2, "lines")) 
 
ggplotly(p, height = 900, tooltip = c("Año", "valores"))

```

<br>

La proyección a 5 años revela un escenario de crecimiento desigual que expone las fracturas estructurales de la economía española:

* **El Norte se distancia**: Las regiones con mayor renta base (País Vasco, Navarra y Madrid) presentan una pendiente de crecimiento robusta y constante, consolidando su liderazgo y alejándose del promedio nacional.

* **Convergencia Lenta**: La mayoría de comunidades (Castilla y León, Aragón, Cataluña) mantienen una tendencia positiva pero moderada, alineada con la media nacional.

* **Rezago Estructural**: Regiones como Extremadura, Canarias y Andalucía, aunque crecen, lo hacen a un ritmo insuficiente para cerrar la brecha con el norte, perpetuando la disparidad territorial observada en el análisis histórico.

* **La Anomalía de Ceuta y Melilla (Decrecimiento)**: El dato más alarmante lo arrojan las ciudades autónomas. A diferencia del resto del país, el modelo predice un estancamiento o ligero decrecimiento de la renta per cápita. Esto sugiere un desacople estructural preocupante: mientras la península se recupera, estas economías, condicionadas por su especificidad fronteriza y demográfica, no logran sumarse a la inercia de crecimiento general, ampliando drásticamente la brecha de desigualdad.

<br>
<hr>
<br>


Tras identificar las marcadas disparidades geográficas tanto en la renta disponible como en la inversión productiva, es fundamental profundizar en la estructura subyacente de la economía regional europea. Para ello, aplicamos un **Análisis de Componentes Principales (PCA)** con el objetivo de reducir la dimensionalidad de los múltiples indicadores económicos y sociales. Este análisis nos permitirá determinar qué combinaciones de variables explican mejor la varianza entre las regiones, identificando si existe un patrón común que agrupe a las regiones ricas frente a las rezagadas, y qué peso tienen factores como los salarios, las prestaciones sociales o la inversión en dicha diferenciación.

Para realizar este análisis vamos generar un atributo combinado formado por el indicador económico y su dirección de flujo, es decir, si ha sido pagado, recibido, o es el resultado de un balance, hacemos esto ya que hay atributos con más de una dirección de flujo.

Primero veremos un gráfico de barras que nos mostrará que porcentaje de la **dispersión de los datos** explica cada componente y luego graficaremos la primera componente (eje x) y la segunda componente (eje y) para poder tener una visualización de dichas componentes.

<br> 

```{r}

mapa_codigos_cortos <- c("B5N" = "ingreso_primario (B5N)", "B6N" = "renta_disponible (B6N)", "B7N" = "ahorro_neto (B7N)","D5" = "impuestos_s_r_p (D5)", "D1" = "remuneracion_asalariados (D1)", "D62" = "prestaciones_sociales (D62)","D4" = "rentas_prop (D4)", "P3" = "gasto_final (P3)", "P51C" = "inversion_fija (P51C)",
"D61" = "cotizaciones_sociales (D61)", "D63" = "transfer_sociales (D63)", "B2A3N" = "exc_bruto_exp_rent (B2A3N)", "D7" = "otras_transferencias (D7)")

indicadores.pca <- c("B2A3N", "B5N",   "B6N",   "B7N",   "D4",    "D5",    "D61",   "D62", "D7", "P51C","D1", "D63","P3")

pca.comunidades.orig <- data  %>% 
  filter(unit == 'MIO_EUR', NUTS == 2, substr(geo,1,2) == 'ES', na_item %in% indicadores.pca, TIME_PERIOD == 2022) %>% 
  left_join(poblacion, by = c('geo', 'TIME_PERIOD')) %>% 
  mutate(per.capita = (values * 1000000) / (poblacion * 1000)) %>% 
  select(-values) %>% 
  rename(values = per.capita) %>% 
  mutate(na_item = dplyr::recode(na_item, !!!mapa_codigos_cortos)) %>%
  mutate(atrib.comb = paste(na_item, "/", direct)) %>% 
  select(full_name, atrib.comb, values) %>% 
  pivot_wider(names_from = atrib.comb, values_from = values) %>% 
  rename(Región = full_name) %>% 
  na.omit()



```

```{r}
pca.comunidades.atribest <- pca.comunidades.orig %>% 
  column_to_rownames(var="Región") %>%
  scale() %>%
  as_tibble() %>% 
  mutate(Región = pca.comunidades.orig$Región) %>%
  relocate(Región)
```

```{r}
pca.comunidades <- pca.comunidades.atribest %>% 
    column_to_rownames(var="Región") 

pca.comunidades.modelo <- prcomp(pca.comunidades,scale = TRUE)
```

```{r}
pca.comunidades.pesoscomb <- as_tibble(pca.comunidades.modelo$rotation, rownames = "Indicador")
```

```{r}
pca <- pca.comunidades.modelo
    
p <- tibble(
  label=fct_inorder(paste("PC",1:length(pca$sdev))),
  varPercent = pca$sdev^2/sum(pca$sdev^2) * 100
) %>%
  ggplot(aes(x=label,
             y=varPercent,
             fill = label,
             text = paste("Componente:", label, 
                          "<br>Varianza:", round(varPercent, 2), "%"))) +
    geom_bar(stat = "identity") +
    labs(x= "Componentes Principales", 
          y= "Porcentaje varianza explicada"
    )+
   geom_text(aes(label=paste0(round(varPercent,digits = 1),"%")), 
                 size=3,
                 colour = "blue",
                 nudge_y = 1.
             ) + 
   theme(legend.position = 'none')

ggplotly(p, tooltip = 'text')
```

<br>

El gráfico de sedimentación revela una estructura de datos altamente redundante, donde el **primer componente principal (PC1)** domina de manera abrumadora, capturando el **64.8%** de la varianza total. Esto indica que la gran mayoría de las diferencias económicas entre las comunidades autónomas se pueden explicar por un único factor latente, muy probablemente relacionado con el **tamaño y la riqueza general** de la economía regional.

El segundo y tercer componente (PC2 y PC3) aportan un 11.2% y 10.7% respectivamente, sugiriendo matices adicionales (posiblemente relacionados con la estructura del mercado laboral o la especialización sectorial). Sin embargo, a partir del PC4, la varianza explicada cae drásticamente por debajo del 5%, lo que confirma que con solo los tres primeros componentes (que suman casi el **87%** de la información) podemos obtener una representación muy fiel de la realidad socioeconómica regional, simplificando enormemente el análisis multivariante.

<br>

```{r}
hchart(pca.comunidades.modelo, choices = c(1, 2)) %>% 
 hc_tooltip(
 useHTML = TRUE,
 headerFormat = "{point.key}<br>"
 ) 
```

<br>

La proyección de las comunidades en el plano definido por el PC1 (Eje X: Tamaño y Riqueza) y el PC2 (Eje Y: Estructura de Bienestar) revela tres clústeres diferenciados:

* **El Polo de Poder Económico (Derecha):** **Madrid y País Vasco** se sitúan en el extremo derecho positivo del PC1, seguidos por **Cataluña e Islas Baleares**. Esto confirma que son los motores económicos de España, con los valores más altos en casi todos los indicadores absolutos (Renta, Inversión, PIB).

* **El Eje Industrial y de Bienestar (Centro-Derecha):** **Navarra, La Rioja y Aragón** ocupan una posición destacada, no solo en riqueza (PC1 alto), sino también diferenciados en el PC2, lo que sugiere una estructura de ingresos y bienestar particular, posiblemente ligada a su régimen foral y tejido industrial.

* **La Periferia Dependiente (Izquierda):** Regiones como **Extremadura, Castilla-La Mancha y las Ciudades Autónomas** se agrupan en el lado negativo del PC1. Su posición indica una menor magnitud económica y una mayor dependencia relativa de las transferencias sociales frente a la generación de rentas primarias. Vemos que regiones como **Canarias, Galacia o Cantabria** se sitúan más en el Centro-Izquierda.
 

 Es decir, el eje horizontal (PC1) actúa como un claro gradiente de **desarrollo económico**, ordenando a las comunidades desde las economías más subsidiadas hacia las más productivas y dinámicas.

<br>
<hr>
<br>

Después de este breve análisis, vamos a pasar a analizar España como país conjunto.

Para empezar vamos a ver una predicción hasta 2030 de la evolución de la **renta neta per cápita** en España. En este caso también veremos una **descomposición STL** de la serie temporal a la que aplicamos el modelo ARIMA. Para una mayor precisión filtraremos a partir del año 2002 ya que fue cuando se introdujo el euro a España.

<br>
```{r}


datatsrenta.spain <- data %>%
  filter(geo == 'ES' & unit == 'EUR_HAB' & na_item == 'B6N' & TIME_PERIOD > 2001) %>%
  select(TIME_PERIOD, values) %>%
  arrange(TIME_PERIOD) %>%
  rename(Año = TIME_PERIOD,
         valores = values) %>% 
  as_tsibble(index = Año) %>%
  fill_gaps() 
    

```


```{r, results = F}
datatsrenta.spain.arima <- datatsrenta.spain %>%
  model(ARIMA()) %>%
  report(fit)
```


```{r}
datatsrenta.spain.arima.pred <- datatsrenta.spain.arima %>%
  forecast(h = 8) 

datatsrenta.spain.titulo <- "Predicción de la evolución de la Renta Neta (España)"
GraficoDinamicoArima95CI(datatsrenta.spain, "Año", "valores", datatsrenta.spain.arima.pred, datatsrenta.spain.titulo) %>% 
  layout(xaxis = list(title = "Año"),
    yaxis = list(title = "Renta Neta (€/Habitante)"))

```

<br>

Consolidando el análisis a nivel nacional, el modelo ARIMA para **España** proyecta una **recuperación robusta y sostenida** hasta 2030. Tras la caída abrupta de 2020 y su posterior rebote en "V", la tendencia central (línea azul) sugiere que la renta neta per cápita superará holgadamente los máximos históricos previos a la crisis financiera, acercándose a los **19.000€.**

Sin embargo, la notable apertura del **intervalo de confianza** (zona sombreada) a medida que nos alejamos en el tiempo advierte de una **incertidumbre macroeconómica creciente.** Aunque la inercia es positiva, la volatilidad del contexto global podría condicionar la magnitud final de este crecimiento.
```{r}
renta.neta <- datatsrenta.spain$valores
datatsrenta.spain.STL <- datatsrenta.spain %>% 
  model(STL(renta.neta, robust = TRUE)) %>% 
  components()
```

```{r}
datatsrenta.spain.STL.plot <- datatsrenta.spain.STL %>% 
  autoplot() +
  theme_bw(base_size = 12) + 
  theme(panel.spacing.y = unit(1.5, "lines")) + 
  labs(title = "Descomposición STL (Evolución de la Renta Neta)")

ggplotly(datatsrenta.spain.STL.plot)
```

<br>

El análisis de descomposición de la serie temporal permite aislar los componentes estructurales de la renta neta española.

* **Tendencia (Trend):** El componente de tendencia es el dominante, mostrando una **trayectoria ascendente clara y suave** a largo plazo. A pesar de las crisis, la inercia subyacente de la renta es de crecimiento continuo, lo que valida la robustez de la recuperación estructural.

* **Residuo (Remainder):** El panel inferior revela las **perturbaciones de origen externo**. Se observan picos negativos muy marcados que coinciden con los grandes shocks económicos: la crisis financiera (2011-2013) y el impacto de la pandemia (2020). Estos residuos de gran magnitud confirman que las caídas de renta no fueron cambios de tendencia estructural, sino eventos puntuales de alta volatilidad que el modelo ARIMA debe absorber.

<br>
<hr>
<br>

Una vez proyectada la senda de recuperación de la renta neta, es imprescindible analizar la contrapartida fiscal que acompaña a este crecimiento. Dado que el sistema tributario español es progresivo y que la renta disponible depende directamente de la capacidad recaudatoria del Estado para sostener los servicios públicos, el siguiente paso lógico es modelar la evolución esperada de la **presión fiscal directa.** A continuación, aplicamos el mismo modelo predictivo ARIMA para estimar cómo evolucionará la carga de **Impuestos sobre la Renta y el Patrimonio** que soportarán los hogares españoles en el próximo lustro.

Al igual que antes, filtraremos a partir del año 2002 ya que fue cuando se introdujo el euro a España y además veremos una descomposición STL de la serie temporal a la que se aplica el modelo ARIMA.


<br>

```{r}
datatsimp.spain <- data %>%
  filter(na_item == 'D5' & geo == 'ES' & unit == 'MIO_EUR' & TIME_PERIOD > 2001) %>%
  left_join(poblacion, by = c('geo', 'TIME_PERIOD')) %>%
  mutate(per.capita = (values * 1000000) / (poblacion * 1000)) %>% 
  select(-values) %>%
  rename(values = per.capita) %>%
  select(TIME_PERIOD, values) %>% 
  arrange(TIME_PERIOD, values) %>%
  rename(Año = TIME_PERIOD,
         valores = values) %>% 
  as_tsibble(index = Año) %>%
  fill_gaps()

```


```{r message=FALSE, warning=FALSE, results= 'hide'}
datatsimp.spain.arima <- datatsimp.spain %>%
  model(ARIMA()) %>%
  report(fit)
```

```{r}
datatsimp.spain.arima.pred <- datatsimp.spain.arima %>%
  forecast(h = 8) 

datatsimp.spain.arima.titulo <- "Predicción de la evolución de Impuestos sobre Renta y Patrimonio (España)"

GraficoDinamicoArima95CI(datatsimp.spain, "Año", "valores", datatsimp.spain.arima.pred, datatsimp.spain.arima.titulo) %>% 
    layout(xaxis = list(title = "Año"),
    yaxis = list(title = "Impuestos (€/Habitante)"))
```

<br>

La proyección para los **Impuestos sobre la Renta y Patrimonio** dibuja un escenario de **crecimiento sostenido y proporcional** a la recuperación económica general.

* **Tendencia Estructural:** El modelo anticipa una subida constante de la recaudación per cápita, proyectando superar los **3.500€ por habitante** hacia 2030. Esta trayectoria alcista replica la pendiente observada en la renta neta, lo que sugiere un sistema fiscal estable que captura riqueza al mismo ritmo que esta se genera, sin indicios de un endurecimiento desproporcionado de la presión fiscal en el modelo actual.

* **Recuperación en "V":** Tras la caída de 2020, la recuperación de los ingresos tributarios es rápida y robusta, marcando nuevos máximos históricos ya en el corto plazo. Esto confirma la eficacia de los estabilizadores automáticos y la resiliencia de la base imponible española.

* **Incertidumbre a Largo Plazo:** El abanico del intervalo de confianza (95%) se abre significativamente a partir de 2025. Esto refleja que, aunque la inercia es de crecimiento, la cifra final dependerá de factores externos (inflación, tipos de interés) y de posibles reformas normativas que el modelo puramente estadístico no puede anticipar.

<br>

```{r}
impuestos <- datatsimp.spain$valores
datatsimp.spain.STL <- datatsimp.spain %>% 
  model(STL(impuestos, robust = TRUE)) %>% 
  components()
```

```{r}
datatsimp.spain.STL.plot <- datatsimp.spain.STL %>% 
  autoplot() +
  theme_bw(base_size = 12) +
  theme(panel.spacing.y = unit(1, "lines")) +
  labs(title = "Descomposición STL (Evolución de Impuestos_R_P)")

ggplotly(datatsimp.spain.STL.plot)
```

<br>

La descomposición de la serie temporal de impuestos revela una estructura más compleja que la de la renta:

* **Tendencia Creciente y Acelerada:** El componente de tendencia (Trend) muestra un crecimiento constante desde el año 2000, pero con una **pendiente que se agudiza notablemente a partir de 2015.** Esto confirma un aumento estructural de la presión fiscal per cápita, impulsada posiblemente por la recuperación económica y cambios normativos que han elevado la recaudación media.

* **Residuo Cíclico:** A diferencia de la renta, el componente irregular (Remainder) presenta **fluctuaciones más frecuentes y pronunciadas**, especialmente visibles durante los periodos de crisis (2008-2012 y 2020). Esta mayor volatilidad en los residuos sugiere que la recaudación de impuestos es mucho más sensible a los ciclos económicos cortos y a las medidas políticas puntuales que la renta base de los hogares.


<br>
<hr>
<br>


Ya que hemos realizado una predicción sobre renta neta e impuestos, puede ser interesante sumar a dichos impuestos sobre renta y patrimonio el total de salarios y cotizaciones sociales pagadas por los empleadores para tener una mejor estimación sobre la presión fiscal y **ver la relación** de esta con la renta neta por países, ambas variables medidas en euros per cápita.

Esto lo veremos mediante un diagrama de dispersión utilizando un **modelo de regresión lineal** y además aplicando una **transformación yeojohnson** sobre la variable del eje y (Renta Neta) y tomaremos el último año de las observaciones (2022).

<br>

```{r}
data.imp.yeoj <- data %>% 
  filter(NUTS == 0, na_item %in% c("D5", "B6N", "D61"), unit == 'MIO_EUR', TIME_PERIOD == 2022, direct %in% c("BAL", "PAID")) %>% 
  left_join(poblacion, by = c("geo", "TIME_PERIOD")) %>% 
  mutate(per.capita = (values * 1000000) / (poblacion * 1000)) %>% 
  select(-values) %>% 
  rename(values = per.capita) %>% 
  select(-direct) %>% 
  pivot_wider(names_from = na_item, values_from = values) %>% 
  mutate(total.impuestos = D5 + D61) %>% 
  select(full_name, geo, TIME_PERIOD, B6N, total.impuestos) %>% 
  rename(Renta = B6N,
         Impuestos = total.impuestos,
         Región = full_name) 

    lambda <- 1  
    lambda <- optimize.yeojohnson.R2(data.imp.yeoj$Renta, data.imp.yeoj$Impuestos)  
    data.imp.yeoj$total.impuestos <- yeo.johnson(data.imp.yeoj$Impuestos,lambda)
    
    p <- data.imp.yeoj %>%
    ggplot(aes(Renta,
               Impuestos,
               label = Región)) + 
    geom_point() +
    theme(legend.position = "none") +
    geom_smooth(method = lm, se = FALSE) + 
      labs(x = "Renta (€/HAB)",
           y = "Presión fiscal (€/HAB)") + 
      theme_bw(base_size = 14) + 
      labs(title = "Relación entre renta neta y Presión Fiscal por países (2022)") + 
      theme_bw(base_size = 12)

  
  ggplotly(p, tooltip = c("Región", "Renta", "Impuestos"))
```

<br>

El gráfico revela una **correlación positiva muy fuerte** y lineal: en Europa, disfrutar de una mayor renta disponible va intrínsecamente ligado a soportar una mayor carga fiscal. No hay países "ricos y baratos"; el bienestar se paga.

**Puntos Clave y Curiosidades:**

* **La Anomalía Danesa: Dinamarca** es el caso más llamativo. Se sitúa muy por encima de la línea de tendencia, lo que indica un **esfuerzo fiscal extraordinario.** A niveles de renta similares a Alemania o Austria, un danés paga mucho más. Esto se debe a su modelo de bienestar único, financiado casi exclusivamente por impuestos directos a la renta en lugar de cotizaciones patronales invisibles.

* **El Equilibrio Español: España** aparece justo sobre la línea de regresión, en la zona media. Esto desmiente la idea de anomalía: la presión fiscal que soportan los hogares españoles ($~6.000\text{€}$) es **matemáticamente consistente con su nivel de renta** ($~17.000\text{€}$). España recauda exactamente lo que se espera para una economía de su tamaño en el contexto europeo.

* **La Brecha Estructural:** Existe una clara polarización. Mientras que el bloque de Europa del Este (Bulgaria, Rumanía) apenas alcanza los $2.000\text{€}$ de contribución fiscal (limitando su capacidad de gasto público), las economías centrales (Bélgica, Alemania) triplican o cuadruplican esa cifra, permitiéndose servicios públicos mucho más robustos. La riqueza genera la base imponible necesaria para el Estado del Bienestar.

<br>
<hr>
<br>

Por último, tras haber visto un diagrama de dispersión para ver la relación entre dos variables, hagamos una **matriz de correlación** utilizando un atributo combinado formado por la variable económica y su dirección de flujo para ver como se relacionan en general todas las variables entre países en el año 2022.

<br>

```{r, fig.height= 8, fig.width= 10}

mapa_codigos_cortos <- c("B5N" = "ingreso_primario (B5N)", "B6N" = "renta_disponible (B6N)", "B7N" = "ahorro_neto (B7N)","D5" = "impuestos_s_r_p (D5)", "D1" = "remuneracion_asalariados (D1)", "D62" = "prestaciones_sociales (D62)","D4" = "rentas_prop (D4)", "P3" = "gasto_final (P3)", "P51C" = "inversion_fija (P51C)",
"D61" = "cotizaciones_sociales (D61)", "D63" = "transfer_sociales (D63)", "B2A3N" = "exc_bruto_exp_rent (B2A3N)", "D7" = "otras_transferencias (D7)")

indicadores.matriz <- c("B5N", "B6N", "B7N", "D1", "D62", "D5", "D4", "P3", "P51C")

data.tb.matrizcorr <- data %>% 
  filter(NUTS == 0, na_item %in% indicadores.matriz, unit == "MIO_EUR", TIME_PERIOD == 2022) %>% 
  left_join(poblacion, by = c("geo", "TIME_PERIOD")) %>% 
    mutate(per.capita = (values * 1000000) / (poblacion * 1000)) %>%
    select(-values) %>%
    mutate(na_item = dplyr::recode(na_item, !!!mapa_codigos_cortos)) %>%
    mutate(atrib.comb = paste(na_item, "/", direct)) %>% 
    rename(values = per.capita) %>% 
    select(full_name, atrib.comb, values) %>% 
    pivot_wider(names_from = atrib.comb, values_from = values) %>% 
    rename(Región = full_name) 


data.tb.matrizcorr %>% 
  select(-Región) %>% 
  cor(use='complete.obs') %>% 
  plot_correlation(show_values = TRUE) %>% 
  layout(title = "Correlación de indicadores por países (2022)")
  
```

<br>

La matriz de correlación revela una estructura económica altamente interconectada, dominada por un **bloque central de correlaciones positivas muy fuertes (>0.9)** entre los principales agregados macroeconómicos. Esto indica que el **tamaño y la riqueza de la economía son los factores determinantes:** los países con mayor Ingreso Primario también tienen sistemáticamente mayor Renta Disponible, Ahorro Neto, Gasto Final e Inversión. Es decir, la escala económica dicta la magnitud de todos estos flujos.


**El Ciclo del Bienestar (Renta-Impuestos-Prestaciones):**    

* Existe una correlación casi perfecta (**0.96**) entre el **Ingreso Primario** y los **Impuestos Pagados.** Esto confirma la progresividad fiscal a nivel macroeconómico: las economías que generan más riqueza primaria son las que más recaudan para financiar el estado.

* A su vez, estos Impuestos tienen una correlación altísima (**0.96**) con las **Prestaciones Sociales Recibidas.** Esto evidencia el funcionamiento del sistema de redistribución: la alta recaudación se traduce directamente en un alto retorno social a los hogares.

**La Paradoja de las Prestaciones Pagadas:**

* Las **Prestaciones Sociales Pagadas** (es decir, las que salen de los hogares, no las que reciben) muestran una **correlación negativa débil (-0.23 a -0.29)** con todos los indicadores de riqueza. Esto sugiere que en las economías más ricas, los hogares no son los principales pagadores directos de estas prestaciones (probablemente financiadas por empresas o estado), o que este flujo es contra-cíclico respecto a la riqueza general.

**Inversión y Ahorro:** 

* La **Inversión Fija** y el **Ahorro Neto** tienen una correlación perfecta (**1.0**) con la Renta Disponible. Esto implica que la capacidad de inversión y ahorro de un país no depende de factores culturales o preferencias, sino que es una función directa y lineal de su nivel de renta disponible: más renta disponible se traduce matemáticamente en mayor inversión y ahorro agregado.

 En **conclusión**, el mapa de calor valida un modelo económico europeo cohesivo donde la generación de riqueza primaria impulsa simultáneamente la capacidad fiscal, el gasto social y la inversión productiva y por tanto es normal que en su mayoría las variables estén correlacionadas de manera que cuando una aumenta las demás por lo general también lo hacen ya que así funciona la economía.
 
<br>
<hr>

Todo este análisis realizado se encuentra desarrollado en mayor detalle en el **cuadro de mandos** del proyecto, permitiendo ahí una mayor exploración en profundidad por los diferentes años, indicadores y regiones.

## Evaluación

<!-- desarrollo de esta fase -->

## Despliegue

<br>

El despliegue de este proyecto se ha realizado a través de la **confección de esta memoria y de un cuadro de mandos.**

El cuadro de mandos del proyecto se ha llevado a cabo mediante el uso de las librerías `flexdashboard` y `shiny`, además de que puede verse publicamente gracias a que se encuentra alojado en un **servidor shiny del DIS.** Este cuadro de mandos se divide en 5 pestañas:

* **Series temporales:** En esta pestaña se muestra todo lo relacionado con la **evolución de atributos** desde el año **2000 hasta 2022**, se puede ver la evolución tanto por **países** como por **regiones NUTS 2** de dichos países. En la pestaña se pueden seleccionar opciones tales como elegir la **unidad**, los países o regiones que se desean ver, activar la **escala del eje y libre**, el indicador o incluso se pueden seleccionar **todos los indicadores**, cuando esta opción es seleccionada, los inputs se actualizan de manera que solo se pueda escoger un país o región y ver los indicadores para dicho país o región. En general **todos los inputs son dinámicos** y cambian en función de lo que el dataset nos ofrece para asegurarnos de que siempre se muestra algo por pantalla, también se han utilizado **funciones reactivas** que permiten **normalizar** muchos de los atributos para convertirlos a **per cápita** y también adaptar la información del gráfico a los inputs seleccionados, la mayoría de atributos solo se encuentran disponibles en **euros por habitante**, siendo que por unidades **PPS per cápita** hay pocos datos disponibles.
Se imprime una **tabla** en la parte inferior de los inputs como resultado del filtrado de dichos inputs para tener una manera distinta de visualizar los datos. Por último es importante saber que cuando se ve la evolución por **regiones** de un país la unidad obligatoria es la de **euros por habitante**, el primer motivo es por la falta de datos en comunidades que no son las Españolas, el segundo es que para ver la evolución dentro de un país, no tiene mucho sentido usar unidades PPS ya que no están comparando regiones con mucha diferencia en el nivel de vida.

* **Atributos por año:** Esta pestaña está basada en **mapas coropléticos** en los que se puede filtrar por **país, región, indicador y año.** Al igual que en la primera pestaña, se han implementado **inputs dinámicos.** Por último, al igual que en la primera pestaña, también se han utilizado **funciones reactivas** que permiten **normalizar** muchos de los atributos para convertirlos a **per cápita** y también adaptar la información del gráfico a los inputs seleccionados, la mayoría de atributos solo se encuentran disponibles en **euros por habitante**, siendo que por unidades **PPS per cápita** hay pocos datos disponibles. Se imprime una **tabla** en la parte inferior de los inputs como resultado del filtrado de dichos inputs para tener una manera distinta de visualizar los datos.

* **Comparación de atributos:** En esta pestaña se utiliza un **diagrama de dispersión** para ver **la relación entre dos variables económicas** en el cual se pueden seleccionar el año inicial a partir del cual se toman los datos y las dos variables a comparar por país o región de dicho país. A dichos atributos se les puede aplicar **transformaciones** tales como **raíz cuadrada, transformaciones logarítmicas o yeojohnson** que permiten mejorar el **modelo de regresión lineal**, dando resultados más fieles a la realidad. En este caso no se da la opción de elegir la unidad y todos los atributos se encuentran en **euros per cápita** ya que para **unidades PPS por habitante** apenas hay observaciones, al igual que en las demás pestañas se han tenido que **normalizar** muchos atributos para convertirlos en atributos per cápita. Se imprime una **tabla** con los resultados del filtrado de los inputs a la derecha como una manera distinta de ver los datos.

* **Predicción con ARIMA:** En esta pestaña se utiliza un **modelo ARIMA** para hacer una **predicción** de un indicador económico a elegir, se permite elegir el **año** a partir del cual se empiezan a tomar los datos de la serie temporal, el **número de años** a predecir, los **parámetros** para el modelo ARIMA y un **máximo** de dos países o regiones de dichos países a elegir para visualizar a la vez. Como en todas las pestañas se han tenido que **normalizar** los atributos y cuando se elige ver la predicción por regiones se pierde la opción de seleccionar la unidad por los motivos explicados anteriormente (falta de datos y de sentido). Todos los inputs se adaptan con **dinamismo** de manera que solo se puede seleccionar lo que el dataset nos ofrece.

* **Análisis de atributos:** Por último tenemos esta pestaña que nos permite analizar **todos los atributos** para los que hay observaciones en el dataset, en este caso lo hacemos a un nivel global, siendo que solo podemos elegir el año de las observaciones y si queremos filtrar por regiones **NUTS 0** (países) o regiones **NUTS 2** (comunidades). En función de lo seleccionado tenemos muchas subpestañas que cambian. La primera es una pestaña donde únicamente se ponen los atributos como columnas y se deja el nombre de la región para ver los valores de sus atributos, todos en **euros per cápita** y muchos **normalizados** ya que para las demás unidades aparecerían muy pocos indicadores y el análisis carecería de sentido, a parte de que lo que interesa ver en esta parte es simplemente la relación de las variables y ver cuanto podríamos **reducir la dimensionalidad** de dichas variables de manera que podamos explicar la mayor variación de los datos posible, así que la unidad no es relevante en principio. En segundo lugar vemos una **matriz de correlación** que nos indica que tan correlacionadas están esas variables por países, región o año (en función de los inputs elegidos). Las siguientes subpestañas se centran en **estandarizar los atributos** para poder compararlos y se calculan las **componentes principales**, siendo las últimas dos pestañas las encargadas mostrar que porcentaje de la **dispersión de los datos** explica cada componente y la **visualización** de dichas componentes.   



# Conclusiones y trabajo futuro


## Conclusiones

<!-- Revisión clara y concisa de los hallazgos más relevantes del estudio, vinculados directamente con los objetivos o hipótesis planteados. Reconocimiento honesto de los puntos débiles o restricciones (por ejemplo, tamaño de muestra reducido, falta de datos, sesgos.  Evitar aquí generalidades de ChatGPT --> 

## Trabajo futuro

<!-- Líneas de trabajo futuro, aspectos pendientes, posibles extensiones. --> 


## Anexo. Seguimiento temporal actividades del proyecto  {-} 


<!-- Lo primero que hay que hacer es compartir en modo lectura la hoja de cálculo Google Sheet que habremos descargado del Campus Virtual para registrar las sesiones de trabajo. A continuación se sustituirá, debajo, el enlace que figura en la lectura del archivo (read_sheet) por el enlace compartido que has creado. 

ES OBLIGATORIO TENER ACTUALIZADO ESTE APARTADO EN CADA ENTREGA DEL PROYECTO. 

CADA SESIÓN DE TRABAJO SE DEBE REGISTRAR EN LA GOOGLE SHEET EN EL MOMENTO DE REALIZARSE. EN PARTICULAR EN UNA ENTREGA  DEL PROYECTO NO PUEDEN APARECER SESIONES DE TRABAJOS NUEVAS CON FECHAS ANTERIORES A LA ENTREGA ANTERIOR DEL PROYECTO. 
-->

<!-- 
IMPORTANTE: La primera vez que ejecutes este chunk desde la consola de R se te pedirá gestionar una autorización para usar una cuenta Google. Es decir, en medio de la ejecución del chunk,  ve a la consola de R y ten en cuenta lo que se te pide. 
-->


```{r}
gs4_deauth()
SeguimientoActividadesProyecto <- read_sheet('https://docs.google.com/spreadsheets/d/1iD312qTpwY65gMgeWzOAkbyM-ONU5t0RhibRUIumkeU/edit?gid=0#gid=0') %>%
  as_tibble() 
```

TOTAL HORAS TRABAJADAS EN EL PROYECTO : `r  round(sum(SeguimientoActividadesProyecto$MINUTES/60),digits=2)`


```{r}
actividades <- c("Introducción","Aportaciones del trabajo","Compresión del negocio","Comprensión de los datos","Preparación de los datos","Modelado","Evaluación","Despliegue","Conclusiones y Trabajo Futuro","Otros")
p <- SeguimientoActividadesProyecto%>%
  group_by(ACTIVITY)%>%
   summarise(
     HORAS=round(sum(MINUTES)/60,digits = 1)
   )%>%
  mutate(ACTIVITY=factor(ACTIVITY,levels=actividades)) %>% 
  ggplot(aes(ACTIVITY,HORAS, fill = ACTIVITY)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=HORAS),size=3,colour = "blue",nudge_y = 0.2)+ 
  theme_bw(base_size = 12) + 
  theme(axis.text.x = element_text(angle = 45,hjust=1),
        legend.position = 'none') + 
  labs(x="",y="HORAS TRABAJADAS",title = "TOTAL HORAS TRABAJADAS EN EL PROYECTO POR ACTIVIDAD") 

ggplotly(p)
  
 
```

```{r,cache=FALSE}
p <- SeguimientoActividadesProyecto%>%
  mutate(week=yearweek(as.Date(START))) %>% 
  group_by(week)%>%
   summarise(
     HORAS=round(sum(MINUTES)/60,digits = 1)
   )%>%
  ungroup() %>% 
  ggplot(aes(week,HORAS, fill = week)) +
  theme_bw(base_size = 12) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=HORAS),size=3,colour = "blue",nudge_y = 0.2)+ 
  theme(axis.text.x = element_text(angle = 45,hjust=1),
        legend.position = 'none')+
  labs(x="",y="HORAS TRABAJADAS",title = "TOTAL HORAS TRABAJADAS POR SEMANA")

ggplotly(p)
  
 
```




**DESGLOSE DETALLADO DE LAS SESIONES DE TRABAJO**
```{r}
SeguimientoActividadesProyecto%>% 
  datatable(
  options = list(
    scrollX = TRUE,   # Scroll horizontal
    scrollY = "400px", # Scroll vertical
    paging = FALSE     # Desactiva paginación si quieres solo scroll
  )
)
```
